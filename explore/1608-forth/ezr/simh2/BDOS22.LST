Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   1
BDOS22  Z80

    1                   ;**************************************************************
    2                   ;*
    3                   ;*             C P / M   version   2 . 2
    4                   ;*
    5                   ;*   Reconstructed from memory image on February 27, 1981
    6                   ;*
    7                   ;*                by Clark A. Calkins
    8                   ;*
    9                   ;**************************************************************
   10                   ;
   11                   ;   Set memory limit here. This is the amount of contigeous
   12                   ; ram starting from 0000. CP/M will reside at the end of this space.
   13                   ;
   14                   
   15         0003      IOBYTE   EQU    3               ;i/o definition byte.
   16         0004      TDRIVE   EQU    4               ;current drive name and user number.
   17         0005      ENTRY    EQU    5               ;entry point for the cp/m bdos.
   18         005C      TFCB     EQU    5CH             ;default file control block.
   19         0080      TBUFF    EQU    80H             ;i/o buffer and command line storage.
   20         0100      TBASE    EQU    100H            ;transiant program storage area.
   21                   ;
   22                   ;   Set control character equates.
   23                   ;
   24         0003      CNTRLC   EQU    3               ;control-c
   25         0005      CNTRLE   EQU    05H             ;control-e
   26         0008      BS       EQU    08H             ;backspace
   27         0009      TAB      EQU    09H             ;tab
   28         000A      LF       EQU    0AH             ;line feed
   29         000C      FF       EQU    0CH             ;form feed
   30         000D      CR       EQU    0DH             ;carriage return
   31         0010      CNTRLP   EQU    10H             ;control-p
   32         0012      CNTRLR   EQU    12H             ;control-r
   33         0013      CNTRLS   EQU    13H             ;control-s
   34         0015      CNTRLU   EQU    15H             ;control-u
   35         0018      CNTRLX   EQU    18H             ;control-x
   36         001A      CNTRLZ   EQU    1AH             ;control-z (end-of-file mark)
   37         007F      DEL      EQU    7FH             ;rubout
   38                   ;
   39                   ;   Set origin for CP/M
   40                   ;
   41         E400               ORG    0E400H
   42                   ;
   43 E400  C3 E75C     CBASE:  JP      COMMAND         ;execute command processor (ccp).
   44 E403  C3 E758             JP      CLEARBUF        ;entry to empty input buffer before starting ccp.
   45                   
   46                   ;
   47                   ;   Standard cp/m ccp input buffer. Format is (max length),
   48                   ; (actual length), (char #1), (char #2), (char #3), etc.
   49                   ;
   50 E406  7F          INBUFF:  DB     127             ;length of input buffer.
   51 E407  00                   DB     0               ;current length of contents.
   52 E408  43 6F 70 79          DB     "Copyright"
   53 E411  20 31 39 37          DB     " 1979 (c) by Digital Research      "
   54 E434  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   55 E44B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   56 E462  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   57 E479  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   58 E488  E408        INPOINT: DW     INBUFF+2        ;input line pointer
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   2
BDOS22  Z80

   59 E48A  0000        NAMEPNT: DW     0               ;input line pointer used for error message. Points to
   60                   ;                       ;start of name in error.
   61                   ;
   62                   ;   Routine to print (A) on the console. All registers used.
   63                   ;
   64 E48C  5F          PRINT:  LD      E,A             ;setup bdos call.
   65 E48D  0E 02               LD      C,2
   66 E48F  C3 0005             JP      ENTRY
   67                   ;
   68                   ;   Routine to print (A) on the console and to save (BC).
   69                   ;
   70 E492  C5          PRINTB: PUSH    BC
   71 E493  CD E48C             CALL    PRINT
   72 E496  C1                  POP     BC
   73 E497  C9                  RET     
   74                   ;
   75                   ;   Routine to send a carriage return, line feed combination
   76                   ; to the console.
   77                   ;
   78 E498  3E 0D       CRLF:   LD      A,CR
   79 E49A  CD E492             CALL    PRINTB
   80 E49D  3E 0A               LD      A,LF
   81 E49F  C3 E492             JP      PRINTB
   82                   ;
   83                   ;   Routine to send one space to the console and save (BC).
   84                   ;
   85 E4A2  3E 20       SPACE:  LD      A,' '
   86 E4A4  C3 E492             JP      PRINTB
   87                   ;
   88                   ;   Routine to print character string pointed to be (BC) on the
   89                   ; console. It must terminate with a null byte.
   90                   ;
   91 E4A7  C5          PLINE:  PUSH    BC
   92 E4A8  CD E498             CALL    CRLF
   93 E4AB  E1                  POP     HL
   94 E4AC  7E          PLINE2: LD      A,(HL)
   95 E4AD  B7                  OR      A
   96 E4AE  C8                  RET     Z
   97 E4AF  23                  INC     HL
   98 E4B0  E5                  PUSH    HL
   99 E4B1  CD E48C             CALL    PRINT
  100 E4B4  E1                  POP     HL
  101 E4B5  C3 E4AC             JP      PLINE2
  102                   ;
  103                   ;   Routine to reset the disk system.
  104                   ;
  105 E4B8  0E 0D       RESDSK: LD      C,13
  106 E4BA  C3 0005             JP      ENTRY
  107                   ;
  108                   ;   Routine to select disk (A).
  109                   ;
  110 E4BD  5F          DSKSEL: LD      E,A
  111 E4BE  0E 0E               LD      C,14
  112 E4C0  C3 0005             JP      ENTRY
  113                   ;
  114                   ;   Routine to call bdos and save the return code. The zero
  115                   ; flag is set on a return of 0ffh.
  116                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   3
BDOS22  Z80

  117 E4C3  CD 0005     ENTRY1: CALL    ENTRY
  118 E4C6  32 EBEE             LD      (RTNCODE),A     ;save return code.
  119 E4C9  3C                  INC     A               ;set zero if 0ffh returned.
  120 E4CA  C9                  RET     
  121                   ;
  122                   ;   Routine to open a file. (DE) must point to the FCB.
  123                   ;
  124 E4CB  0E 0F       OPEN:   LD      C,15
  125 E4CD  C3 E4C3             JP      ENTRY1
  126                   ;
  127                   ;   Routine to open file at (FCB).
  128                   ;
  129 E4D0  AF          OPENFCB:XOR     A               ;clear the record number byte at fcb+32
  130 E4D1  32 EBED             LD      (FCB+32),A
  131 E4D4  11 EBCD             LD      DE,FCB
  132 E4D7  C3 E4CB             JP      OPEN
  133                   ;
  134                   ;   Routine to close a file. (DE) points to FCB.
  135                   ;
  136 E4DA  0E 10       CLOSE:  LD      C,16
  137 E4DC  C3 E4C3             JP      ENTRY1
  138                   ;
  139                   ;   Routine to search for the first file with ambigueous name
  140                   ; (DE).
  141                   ;
  142 E4DF  0E 11       SRCHFST:LD      C,17
  143 E4E1  C3 E4C3             JP      ENTRY1
  144                   ;
  145                   ;   Search for the next ambigeous file name.
  146                   ;
  147 E4E4  0E 12       SRCHNXT:LD      C,18
  148 E4E6  C3 E4C3             JP      ENTRY1
  149                   ;
  150                   ;   Search for file at (FCB).
  151                   ;
  152 E4E9  11 EBCD     SRCHFCB:LD      DE,FCB
  153 E4EC  C3 E4DF             JP      SRCHFST
  154                   ;
  155                   ;   Routine to delete a file pointed to by (DE).
  156                   ;
  157 E4EF  0E 13       DELETE: LD      C,19
  158 E4F1  C3 0005             JP      ENTRY
  159                   ;
  160                   ;   Routine to call the bdos and set the zero flag if a zero
  161                   ; status is returned.
  162                   ;
  163 E4F4  CD 0005     ENTRY2: CALL    ENTRY
  164 E4F7  B7                  OR      A               ;set zero flag if appropriate.
  165 E4F8  C9                  RET     
  166                   ;
  167                   ;   Routine to read the next record from a sequential file.
  168                   ; (DE) points to the FCB.
  169                   ;
  170 E4F9  0E 14       RDREC:  LD      C,20
  171 E4FB  C3 E4F4             JP      ENTRY2
  172                   ;
  173                   ;   Routine to read file at (FCB).
  174                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   4
BDOS22  Z80

  175 E4FE  11 EBCD     READFCB:LD      DE,FCB
  176 E501  C3 E4F9             JP      RDREC
  177                   ;
  178                   ;   Routine to write the next record of a sequential file.
  179                   ; (DE) points to the FCB.
  180                   ;
  181 E504  0E 15       WRTREC: LD      C,21
  182 E506  C3 E4F4             JP      ENTRY2
  183                   ;
  184                   ;   Routine to create the file pointed to by (DE).
  185                   ;
  186 E509  0E 16       CREATE: LD      C,22
  187 E50B  C3 E4C3             JP      ENTRY1
  188                   ;
  189                   ;   Routine to rename the file pointed to by (DE). Note that
  190                   ; the new name starts at (DE+16).
  191                   ;
  192 E50E  0E 17       RENAM:  LD      C,23
  193 E510  C3 0005             JP      ENTRY
  194                   ;
  195                   ;   Get the current user code.
  196                   ;
  197 E513  1E FF       GETUSR: LD      E,0FFH
  198                   ;
  199                   ;   Routne to get or set the current user code.
  200                   ; If (E) is FF then this is a GET, else it is a SET.
  201                   ;
  202 E515  0E 20       GETSETUC: LD    C,32
  203 E517  C3 0005             JP      ENTRY
  204                   ;
  205                   ;   Routine to set the current drive byte at (TDRIVE).
  206                   ;
  207 E51A  CD E513     SETCDRV:CALL    GETUSR          ;get user number
  208 E51D  87                  ADD     A,A             ;and shift into the upper 4 bits.
  209 E51E  87                  ADD     A,A
  210 E51F  87                  ADD     A,A
  211 E520  87                  ADD     A,A
  212 E521  21 EBEF             LD      HL,CDRIVE       ;now add in the current drive number.
  213 E524  B6                  OR      (HL)
  214 E525  32 0004             LD      (TDRIVE),A      ;and save.
  215 E528  C9                  RET     
  216                   ;
  217                   ;   Move currently active drive down to (TDRIVE).
  218                   ;
  219 E529  3A EBEF     MOVECD: LD      A,(CDRIVE)
  220 E52C  32 0004             LD      (TDRIVE),A
  221 E52F  C9                  RET     
  222                   ;
  223                   ;   Routine to convert (A) into upper case ascii. Only letters
  224                   ; are affected.
  225                   ;
  226 E530  FE 61       UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'.
  227 E532  D8                  RET     C
  228 E533  FE 7B               CP      '{'
  229 E535  D0                  RET     NC
  230 E536  E6 5F               AND     5FH             ;convert it if found.
  231 E538  C9                  RET     
  232                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   5
BDOS22  Z80

  233                   ;   Routine to get a line of input. We must check to see if the
  234                   ; user is in (BATCH) mode. If so, then read the input from file
  235                   ; ($$$.SUB). At the end, reset to console input.
  236                   ;
  237 E539  3A EBAB     GETINP: LD      A,(BATCH)       ;if =0, then use console input.
  238 E53C  B7                  OR      A
  239 E53D  CA E596             JP      Z,GETINP1
  240                   ;
  241                   ;   Use the submit file ($$$.sub) which is prepared by a
  242                   ; SUBMIT run. It must be on drive (A) and it will be deleted
  243                   ; if and error occures (like eof).
  244                   ;
  245 E540  3A EBEF             LD      A,(CDRIVE)      ;select drive 0 if need be.
  246 E543  B7                  OR      A
  247 E544  3E 00               LD      A,0             ;always use drive A for submit.
  248 E546  C4 E4BD             CALL    NZ,DSKSEL       ;select it if required.
  249 E549  11 EBAC             LD      DE,BATCHFCB
  250 E54C  CD E4CB             CALL    OPEN            ;look for it.
  251 E54F  CA E596             JP      Z,GETINP1       ;if not there, use normal input.
  252 E552  3A EBBB             LD      A,(BATCHFCB+15) ;get last record number+1.
  253 E555  3D                  DEC     A
  254 E556  32 EBCC             LD      (BATCHFCB+32),A
  255 E559  11 EBAC             LD      DE,BATCHFCB
  256 E55C  CD E4F9             CALL    RDREC           ;read last record.
  257 E55F  C2 E596             JP      NZ,GETINP1      ;quit on end of file.
  258                   ;
  259                   ;   Move this record into input buffer.
  260                   ;
  261 E562  11 E407             LD      DE,INBUFF+1
  262 E565  21 0080             LD      HL,TBUFF        ;data was read into buffer here.
  263 E568  06 80               LD      B,128           ;all 128 characters may be used.
  264 E56A  CD E842             CALL    HL2DE           ;(HL) to (DE), (B) bytes.
  265 E56D  21 EBBA             LD      HL,BATCHFCB+14
  266 E570  36 00               LD      (HL),0          ;zero out the 's2' byte.
  267 E572  23                  INC     HL              ;and decrement the record count.
  268 E573  35                  DEC     (HL)
  269 E574  11 EBAC             LD      DE,BATCHFCB     ;close the batch file now.
  270 E577  CD E4DA             CALL    CLOSE
  271 E57A  CA E596             JP      Z,GETINP1       ;quit on an error.
  272 E57D  3A EBEF             LD      A,(CDRIVE)      ;re-select previous drive if need be.
  273 E580  B7                  OR      A
  274 E581  C4 E4BD             CALL    NZ,DSKSEL       ;don't do needless selects.
  275                   ;
  276                   ;   Print line just read on console.
  277                   ;
  278 E584  21 E408             LD      HL,INBUFF+2
  279 E587  CD E4AC             CALL    PLINE2
  280 E58A  CD E5C2             CALL    CHKCON          ;check console, quit on a key.
  281 E58D  CA E5A7             JP      Z,GETINP2       ;jump if no key is pressed.
  282                   ;
  283                   ;   Terminate the submit job on any keyboard input. Delete this
  284                   ; file such that it is not re-started and jump to normal keyboard
  285                   ; input section.
  286                   ;
  287 E590  CD E5DD             CALL    DELBATCH        ;delete the batch file.
  288 E593  C3 E782             JP      CMMND1          ;and restart command input.
  289                   ;
  290                   ;   Get here for normal keyboard input. Delete the submit file
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   6
BDOS22  Z80

  291                   ; incase there was one.
  292                   ;
  293 E596  CD E5DD     GETINP1:CALL    DELBATCH        ;delete file ($$$.sub).
  294 E599  CD E51A             CALL    SETCDRV         ;reset active disk.
  295 E59C  0E 0A               LD      C,10            ;get line from console device.
  296 E59E  11 E406             LD      DE,INBUFF
  297 E5A1  CD 0005             CALL    ENTRY
  298 E5A4  CD E529             CALL    MOVECD          ;reset current drive (again).
  299                   ;
  300                   ;   Convert input line to upper case.
  301                   ;
  302 E5A7  21 E407     GETINP2:LD      HL,INBUFF+1
  303 E5AA  46                  LD      B,(HL)          ;(B)=character counter.
  304 E5AB  23          GETINP3:INC     HL
  305 E5AC  78                  LD      A,B             ;end of the line?
  306 E5AD  B7                  OR      A
  307 E5AE  CA E5BA             JP      Z,GETINP4
  308 E5B1  7E                  LD      A,(HL)          ;convert to upper case.
  309 E5B2  CD E530             CALL    UPPER
  310 E5B5  77                  LD      (HL),A
  311 E5B6  05                  DEC     B               ;adjust character count.
  312 E5B7  C3 E5AB             JP      GETINP3
  313 E5BA  77          GETINP4:LD      (HL),A          ;add trailing null.
  314 E5BB  21 E408             LD      HL,INBUFF+2
  315 E5BE  22 E488             LD      (INPOINT),HL    ;reset input line pointer.
  316 E5C1  C9                  RET     
  317                   ;
  318                   ;   Routine to check the console for a key pressed. The zero
  319                   ; flag is set is none, else the character is returned in (A).
  320                   ;
  321 E5C2  0E 0B       CHKCON: LD      C,11            ;check console.
  322 E5C4  CD 0005             CALL    ENTRY
  323 E5C7  B7                  OR      A
  324 E5C8  C8                  RET     Z               ;return if nothing.
  325 E5C9  0E 01               LD      C,1             ;else get character.
  326 E5CB  CD 0005             CALL    ENTRY
  327 E5CE  B7                  OR      A               ;clear zero flag and return.
  328 E5CF  C9                  RET     
  329                   ;
  330                   ;   Routine to get the currently active drive number.
  331                   ;
  332 E5D0  0E 19       GETDSK: LD      C,25
  333 E5D2  C3 0005             JP      ENTRY
  334                   ;
  335                   ;   Set the stabdard dma address.
  336                   ;
  337 E5D5  11 0080     STDDMA: LD      DE,TBUFF
  338                   ;
  339                   ;   Routine to set the dma address to (DE).
  340                   ;
  341 E5D8  0E 1A       DMASET: LD      C,26
  342 E5DA  C3 0005             JP      ENTRY
  343                   ;
  344                   ;  Delete the batch file created by SUBMIT.
  345                   ;
  346 E5DD  21 EBAB     DELBATCH: LD    HL,BATCH        ;is batch active?
  347 E5E0  7E                  LD      A,(HL)
  348 E5E1  B7                  OR      A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   7
BDOS22  Z80

  349 E5E2  C8                  RET     Z
  350 E5E3  36 00               LD      (HL),0          ;yes, de-activate it.
  351 E5E5  AF                  XOR     A
  352 E5E6  CD E4BD             CALL    DSKSEL          ;select drive 0 for sure.
  353 E5E9  11 EBAC             LD      DE,BATCHFCB     ;and delete this file.
  354 E5EC  CD E4EF             CALL    DELETE
  355 E5EF  3A EBEF             LD      A,(CDRIVE)      ;reset current drive.
  356 E5F2  C3 E4BD             JP      DSKSEL
  357                   ;
  358                   ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
  359                   ; the same or we halt....
  360                   ;
  361 E5F5  11 E728     VERIFY: LD      DE,PATTRN1      ;these are the serial number bytes.
  362 E5F8  21 EC00             LD      HL,PATTRN2      ;ditto, but how could they be different?
  363 E5FB  06 06               LD      B,6             ;6 bytes each.
  364 E5FD  1A          VERIFY1:LD      A,(DE)
  365 E5FE  BE                  CP      (HL)
  366 E5FF  C2 E7CF             JP      NZ,HALT         ;jump to halt routine.
  367 E602  13                  INC     DE
  368 E603  23                  INC     HL
  369 E604  05                  DEC     B
  370 E605  C2 E5FD             JP      NZ,VERIFY1
  371 E608  C9                  RET     
  372                   ;
  373                   ;   Print back file name with a '?' to indicate a syntax error.
  374                   ;
  375 E609  CD E498     SYNERR: CALL    CRLF            ;end current line.
  376 E60C  2A E48A             LD      HL,(NAMEPNT)    ;this points to name in error.
  377 E60F  7E          SYNERR1:LD      A,(HL)          ;print it until a space or null is found.
  378 E610  FE 20               CP      ' '
  379 E612  CA E622             JP      Z,SYNERR2
  380 E615  B7                  OR      A
  381 E616  CA E622             JP      Z,SYNERR2
  382 E619  E5                  PUSH    HL
  383 E61A  CD E48C             CALL    PRINT
  384 E61D  E1                  POP     HL
  385 E61E  23                  INC     HL
  386 E61F  C3 E60F             JP      SYNERR1
  387 E622  3E 3F       SYNERR2:LD      A,'?'           ;add trailing '?'.
  388 E624  CD E48C             CALL    PRINT
  389 E627  CD E498             CALL    CRLF
  390 E62A  CD E5DD             CALL    DELBATCH        ;delete any batch file.
  391 E62D  C3 E782             JP      CMMND1          ;and restart from console input.
  392                   ;
  393                   ;   Check character at (DE) for legal command input. Note that the
  394                   ; zero flag is set if the character is a delimiter.
  395                   ;
  396 E630  1A          CHECK:  LD      A,(DE)
  397 E631  B7                  OR      A
  398 E632  C8                  RET     Z
  399 E633  FE 20               CP      ' '             ;control characters are not legal here.
  400 E635  DA E609             JP      C,SYNERR
  401 E638  C8                  RET     Z               ;check for valid delimiter.
  402 E639  FE 3D               CP      '='
  403 E63B  C8                  RET     Z
  404 E63C  FE 5F               CP      '_'
  405 E63E  C8                  RET     Z
  406 E63F  FE 2E               CP      '.'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   8
BDOS22  Z80

  407 E641  C8                  RET     Z
  408 E642  FE 3A               CP      ':'
  409 E644  C8                  RET     Z
  410 E645  FE 3B               CP      03BH ; ';'
  411 E647  C8                  RET     Z
  412 E648  FE 3C               CP      '<'
  413 E64A  C8                  RET     Z
  414 E64B  FE 3E               CP      '>'
  415 E64D  C8                  RET     Z
  416 E64E  C9                  RET     
  417                   ;
  418                   ;   Get the next non-blank character from (DE).
  419                   ;
  420 E64F  1A          NONBLANK: LD    A,(DE)
  421 E650  B7                  OR      A               ;string ends with a null.
  422 E651  C8                  RET     Z
  423 E652  FE 20               CP      ' '
  424 E654  C0                  RET     NZ
  425 E655  13                  INC     DE
  426 E656  C3 E64F             JP      NONBLANK
  427                   ;
  428                   ;   Add (HL)=(HL)+(A)
  429                   ;
  430 E659  85          ADDHL:  ADD     A,L
  431 E65A  6F                  LD      L,A
  432 E65B  D0                  RET     NC              ;take care of any carry.
  433 E65C  24                  INC     H
  434 E65D  C9                  RET     
  435                   ;
  436                   ;   Convert the first name in (FCB).
  437                   ;
  438 E65E  3E 00       CONVFST:LD      A,0
  439                   ;
  440                   ;   Format a file name (convert * to '?', etc.). On return,
  441                   ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
  442                   ; the position within the fcb for the name (either 0 or 16).
  443                   ;
  444 E660  21 EBCD     CONVERT:LD      HL,FCB
  445 E663  CD E659             CALL    ADDHL
  446 E666  E5                  PUSH    HL
  447 E667  E5                  PUSH    HL
  448 E668  AF                  XOR     A
  449 E669  32 EBF0             LD      (CHGDRV),A      ;initialize drive change flag.
  450 E66C  2A E488             LD      HL,(INPOINT)    ;set (HL) as pointer into input line.
  451 E66F  EB                  EX      DE,HL
  452 E670  CD E64F             CALL    NONBLANK        ;get next non-blank character.
  453 E673  EB                  EX      DE,HL
  454 E674  22 E48A             LD      (NAMEPNT),HL    ;save pointer here for any error message.
  455 E677  EB                  EX      DE,HL
  456 E678  E1                  POP     HL
  457 E679  1A                  LD      A,(DE)          ;get first character.
  458 E67A  B7                  OR      A
  459 E67B  CA E689             JP      Z,CONVRT1
  460 E67E  DE 40               SBC     A,'A'-1         ;might be a drive name, convert to binary.
  461 E680  47                  LD      B,A             ;and save.
  462 E681  13                  INC     DE              ;check next character for a ':'.
  463 E682  1A                  LD      A,(DE)
  464 E683  FE 3A               CP      ':'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   9
BDOS22  Z80

  465 E685  CA E690             JP      Z,CONVRT2
  466 E688  1B                  DEC     DE              ;nope, move pointer back to the start of the line.
  467 E689  3A EBEF     CONVRT1:LD      A,(CDRIVE)
  468 E68C  77                  LD      (HL),A
  469 E68D  C3 E696             JP      CONVRT3
  470 E690  78          CONVRT2:LD      A,B
  471 E691  32 EBF0             LD      (CHGDRV),A      ;set change in drives flag.
  472 E694  70                  LD      (HL),B
  473 E695  13                  INC     DE
  474                   ;
  475                   ;   Convert the basic file name.
  476                   ;
  477 E696  06 08       CONVRT3:LD      B,08H
  478 E698  CD E630     CONVRT4:CALL    CHECK
  479 E69B  CA E6B9             JP      Z,CONVRT8
  480 E69E  23                  INC     HL
  481 E69F  FE 2A               CP      '*'             ;note that an '*' will fill the remaining
  482 E6A1  C2 E6A9             JP      NZ,CONVRT5      ;field with '?'.
  483 E6A4  36 3F               LD      (HL),'?'
  484 E6A6  C3 E6AB             JP      CONVRT6
  485 E6A9  77          CONVRT5:LD      (HL),A
  486 E6AA  13                  INC     DE
  487 E6AB  05          CONVRT6:DEC     B
  488 E6AC  C2 E698             JP      NZ,CONVRT4
  489 E6AF  CD E630     CONVRT7:CALL    CHECK           ;get next delimiter.
  490 E6B2  CA E6C0             JP      Z,GETEXT
  491 E6B5  13                  INC     DE
  492 E6B6  C3 E6AF             JP      CONVRT7
  493 E6B9  23          CONVRT8:INC     HL              ;blank fill the file name.
  494 E6BA  36 20               LD      (HL),' '
  495 E6BC  05                  DEC     B
  496 E6BD  C2 E6B9             JP      NZ,CONVRT8
  497                   ;
  498                   ;   Get the extension and convert it.
  499                   ;
  500 E6C0  06 03       GETEXT: LD      B,03H
  501 E6C2  FE 2E               CP      '.'
  502 E6C4  C2 E6E9             JP      NZ,GETEXT5
  503 E6C7  13                  INC     DE
  504 E6C8  CD E630     GETEXT1:CALL    CHECK
  505 E6CB  CA E6E9             JP      Z,GETEXT5
  506 E6CE  23                  INC     HL
  507 E6CF  FE 2A               CP      '*'
  508 E6D1  C2 E6D9             JP      NZ,GETEXT2
  509 E6D4  36 3F               LD      (HL),'?'
  510 E6D6  C3 E6DB             JP      GETEXT3
  511 E6D9  77          GETEXT2:LD      (HL),A
  512 E6DA  13                  INC     DE
  513 E6DB  05          GETEXT3:DEC     B
  514 E6DC  C2 E6C8             JP      NZ,GETEXT1
  515 E6DF  CD E630     GETEXT4:CALL    CHECK
  516 E6E2  CA E6F0             JP      Z,GETEXT6
  517 E6E5  13                  INC     DE
  518 E6E6  C3 E6DF             JP      GETEXT4
  519 E6E9  23          GETEXT5:INC     HL
  520 E6EA  36 20               LD      (HL),' '
  521 E6EC  05                  DEC     B
  522 E6ED  C2 E6E9             JP      NZ,GETEXT5
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  10
BDOS22  Z80

  523 E6F0  06 03       GETEXT6:LD      B,3
  524 E6F2  23          GETEXT7:INC     HL
  525 E6F3  36 00               LD      (HL),0
  526 E6F5  05                  DEC     B
  527 E6F6  C2 E6F2             JP      NZ,GETEXT7
  528 E6F9  EB                  EX      DE,HL
  529 E6FA  22 E488             LD      (INPOINT),HL    ;save input line pointer.
  530 E6FD  E1                  POP     HL
  531                   ;
  532                   ;   Check to see if this is an ambigeous file name specification.
  533                   ; Set the (A) register to non zero if it is.
  534                   ;
  535 E6FE  01 000B             LD      BC,11           ;set name length.
  536 E701  23          GETEXT8:INC     HL
  537 E702  7E                  LD      A,(HL)
  538 E703  FE 3F               CP      '?'             ;any question marks?
  539 E705  C2 E709             JP      NZ,GETEXT9
  540 E708  04                  INC     B               ;count them.
  541 E709  0D          GETEXT9:DEC     C
  542 E70A  C2 E701             JP      NZ,GETEXT8
  543 E70D  78                  LD      A,B
  544 E70E  B7                  OR      A
  545 E70F  C9                  RET     
  546                   ;
  547                   ;   CP/M command table. Note commands can be either 3 or 4 characters long.
  548                   ;
  549         0006      NUMCMDS  EQU    6               ;number of commands
  550 E710  44 49 52 20 CMDTBL:  DB     "DIR "
  551 E714  45 52 41 20          DB     "ERA "
  552 E718  54 59 50 45          DB     "TYPE"
  553 E71C  53 41 56 45          DB     "SAVE"
  554 E720  52 45 4E 20          DB     "REN "
  555 E724  55 53 45 52          DB     "USER"
  556                   ;
  557                   ;   The following six bytes must agree with those at (PATTRN2)
  558                   ; or cp/m will HALT. Why?
  559                   ;
  560 E728  00 16 00 00 PATTRN1: DB     0,22,0,0,0,0    ;(* serial number bytes *).
  561                   ;
  562                   ;   Search the command table for a match with what has just
  563                   ; been entered. If a match is found, then we jump to the
  564                   ; proper section. Else jump to (UNKNOWN).
  565                   ; On return, the (C) register is set to the command number
  566                   ; that matched (or NUMCMDS+1 if no match).
  567                   ;
  568 E72E  21 E710     SEARCH: LD      HL,CMDTBL
  569 E731  0E 00               LD      C,0
  570 E733  79          SEARCH1:LD      A,C
  571 E734  FE 06               CP      NUMCMDS         ;this commands exists.
  572 E736  D0                  RET     NC
  573 E737  11 EBCE             LD      DE,FCB+1        ;check this one.
  574 E73A  06 04               LD      B,4             ;max command length.
  575 E73C  1A          SEARCH2:LD      A,(DE)
  576 E73D  BE                  CP      (HL)
  577 E73E  C2 E74F             JP      NZ,SEARCH3      ;not a match.
  578 E741  13                  INC     DE
  579 E742  23                  INC     HL
  580 E743  05                  DEC     B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  11
BDOS22  Z80

  581 E744  C2 E73C             JP      NZ,SEARCH2
  582 E747  1A                  LD      A,(DE)          ;allow a 3 character command to match.
  583 E748  FE 20               CP      ' '
  584 E74A  C2 E754             JP      NZ,SEARCH4
  585 E74D  79                  LD      A,C             ;set return register for this command.
  586 E74E  C9                  RET     
  587 E74F  23          SEARCH3:INC     HL
  588 E750  05                  DEC     B
  589 E751  C2 E74F             JP      NZ,SEARCH3
  590 E754  0C          SEARCH4:INC     C
  591 E755  C3 E733             JP      SEARCH1
  592                   ;
  593                   ;   Set the input buffer to empty and then start the command
  594                   ; processor (ccp).
  595                   ;
  596 E758  AF          CLEARBUF: XOR   A
  597 E759  32 E407             LD      (INBUFF+1),A    ;second byte is actual length.
  598                   ;
  599                   ;**************************************************************
  600                   ;*
  601                   ;*
  602                   ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
  603                   ;*
  604                   ;**************************************************************
  605                   ;*
  606 E75C  31 EBAB     COMMAND:LD      SP,CCPSTACK     ;setup stack area.
  607 E75F  C5                  PUSH    BC              ;note that (C) should be equal to:
  608 E760  79                  LD      A,C             ;(uuuudddd) where 'uuuu' is the user number
  609 E761  1F                  RRA                     ;and 'dddd' is the drive number.
  610 E762  1F                  RRA     
  611 E763  1F                  RRA     
  612 E764  1F                  RRA     
  613 E765  E6 0F               AND     0FH             ;isolate the user number.
  614 E767  5F                  LD      E,A
  615 E768  CD E515             CALL    GETSETUC        ;and set it.
  616 E76B  CD E4B8             CALL    RESDSK          ;reset the disk system.
  617 E76E  32 EBAB             LD      (BATCH),A       ;clear batch mode flag.
  618 E771  C1                  POP     BC
  619 E772  79                  LD      A,C
  620 E773  E6 0F               AND     0FH             ;isolate the drive number.
  621 E775  32 EBEF             LD      (CDRIVE),A      ;and save.
  622 E778  CD E4BD             CALL    DSKSEL          ;...and select.
  623 E77B  3A E407             LD      A,(INBUFF+1)
  624 E77E  B7                  OR      A               ;anything in input buffer already?
  625 E77F  C2 E798             JP      NZ,CMMND2       ;yes, we just process it.
  626                   ;
  627                   ;   Entry point to get a command line from the console.
  628                   ;
  629 E782  31 EBAB     CMMND1: LD      SP,CCPSTACK     ;set stack straight.
  630 E785  CD E498             CALL    CRLF            ;start a new line on the screen.
  631 E788  CD E5D0             CALL    GETDSK          ;get current drive.
  632 E78B  C6 41               ADD     A,'A'
  633 E78D  CD E48C             CALL    PRINT           ;print current drive.
  634 E790  3E 3E               LD      A,'>'
  635 E792  CD E48C             CALL    PRINT           ;and add prompt.
  636 E795  CD E539             CALL    GETINP          ;get line from user.
  637                   ;
  638                   ;   Process command line here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  12
BDOS22  Z80

  639                   ;
  640 E798  11 0080     CMMND2: LD      DE,TBUFF
  641 E79B  CD E5D8             CALL    DMASET          ;set standard dma address.
  642 E79E  CD E5D0             CALL    GETDSK
  643 E7A1  32 EBEF             LD      (CDRIVE),A      ;set current drive.
  644 E7A4  CD E65E             CALL    CONVFST         ;convert name typed in.
  645 E7A7  C4 E609             CALL    NZ,SYNERR       ;wild cards are not allowed.
  646 E7AA  3A EBF0             LD      A,(CHGDRV)      ;if a change in drives was indicated,
  647 E7AD  B7                  OR      A               ;then treat this as an unknown command
  648 E7AE  C2 EAA5             JP      NZ,UNKNOWN      ;which gets executed.
  649 E7B1  CD E72E             CALL    SEARCH          ;else search command table for a match.
  650                   ;
  651                   ;   Note that an unknown command returns
  652                   ; with (A) pointing to the last address
  653                   ; in our table which is (UNKNOWN).
  654                   ;
  655 E7B4  21 E7C1             LD      HL,CMDADR       ;now, look thru our address table for command (A).
  656 E7B7  5F                  LD      E,A             ;set (DE) to command number.
  657 E7B8  16 00               LD      D,0
  658 E7BA  19                  ADD     HL,DE
  659 E7BB  19                  ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number).
  660 E7BC  7E                  LD      A,(HL)          ;now pick out this address.
  661 E7BD  23                  INC     HL
  662 E7BE  66                  LD      H,(HL)
  663 E7BF  6F                  LD      L,A
  664 E7C0  E9                  JP      (HL)            ;now execute it.
  665                   ;
  666                   ;   CP/M command address table.
  667                   ;
  668 E7C1  E877  E91F  CMDADR:  DW     DIRECT,ERASE,TYPE,SAVE
  669 E7C9  EA10  EA8E           DW     RENAME,USER,UNKNOWN
  670                   ;
  671                   ;   Halt the system. Reason for this is unknown at present.
  672                   ;
  673 E7CF  21 76F3     HALT:   LD      HL,76F3H        ;'DI HLT' instructions.
  674 E7D2  22 E400             LD      (CBASE),HL
  675 E7D5  21 E400             LD      HL,CBASE
  676 E7D8  E9                  JP      (HL)
  677                   ;
  678                   ;   Read error while TYPEing a file.
  679                   ;
  680 E7D9  01 E7DF     RDERROR:LD      BC,RDERR
  681 E7DC  C3 E4A7             JP      PLINE
  682 E7DF  52 65 61 64 RDERR:   DB     "Read error"
  683 E7E9  00                   DB     0
  684                   ;
  685                   ;   Required file was not located.
  686                   ;
  687 E7EA  01 E7F0     NONE:   LD      BC,NOFILE
  688 E7ED  C3 E4A7             JP      PLINE
  689 E7F0  4E 6F 20 66 NOFILE:  DB     "No file"
  690 E7F7  00                   DB     0
  691                   ;
  692                   ;   Decode a command of the form 'A>filename number{ filename}.
  693                   ; Note that a drive specifier is not allowed on the first file
  694                   ; name. On return, the number is in register (A). Any error
  695                   ; causes 'filename?' to be printed and the command is aborted.
  696                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  13
BDOS22  Z80

  697 E7F8  CD E65E     DECODE: CALL    CONVFST         ;convert filename.
  698 E7FB  3A EBF0             LD      A,(CHGDRV)      ;do not allow a drive to be specified.
  699 E7FE  B7                  OR      A
  700 E7FF  C2 E609             JP      NZ,SYNERR
  701 E802  21 EBCE             LD      HL,FCB+1        ;convert number now.
  702 E805  01 000B             LD      BC,11           ;(B)=sum register, (C)=max digit count.
  703 E808  7E          DECODE1:LD      A,(HL)
  704 E809  FE 20               CP      ' '             ;a space terminates the numeral.
  705 E80B  CA E833             JP      Z,DECODE3
  706 E80E  23                  INC     HL
  707 E80F  D6 30               SUB     '0'             ;make binary from ascii.
  708 E811  FE 0A               CP      10              ;legal digit?
  709 E813  D2 E609             JP      NC,SYNERR
  710 E816  57                  LD      D,A             ;yes, save it in (D).
  711 E817  78                  LD      A,B             ;compute (B)=(B)*10 and check for overflow.
  712 E818  E6 E0               AND     0E0H
  713 E81A  C2 E609             JP      NZ,SYNERR
  714 E81D  78                  LD      A,B
  715 E81E  07                  RLCA    
  716 E81F  07                  RLCA    
  717 E820  07                  RLCA                    ;(A)=(B)*8
  718 E821  80                  ADD     A,B             ;.......*9
  719 E822  DA E609             JP      C,SYNERR
  720 E825  80                  ADD     A,B             ;.......*10
  721 E826  DA E609             JP      C,SYNERR
  722 E829  82                  ADD     A,D             ;add in new digit now.
  723 E82A  DA E609     DECODE2:JP      C,SYNERR
  724 E82D  47                  LD      B,A             ;and save result.
  725 E82E  0D                  DEC     C               ;only look at 11 digits.
  726 E82F  C2 E808             JP      NZ,DECODE1
  727 E832  C9                  RET     
  728 E833  7E          DECODE3:LD      A,(HL)          ;spaces must follow (why?).
  729 E834  FE 20               CP      ' '
  730 E836  C2 E609             JP      NZ,SYNERR
  731 E839  23                  INC     HL
  732 E83A  0D          DECODE4:DEC     C
  733 E83B  C2 E833             JP      NZ,DECODE3
  734 E83E  78                  LD      A,B             ;set (A)=the numeric value entered.
  735 E83F  C9                  RET     
  736                   ;
  737                   ;   Move 3 bytes from (HL) to (DE). Note that there is only
  738                   ; one reference to this at (A2D5h).
  739                   ;
  740 E840  06 03       MOVE3:  LD      B,3
  741                   ;
  742                   ;   Move (B) bytes from (HL) to (DE).
  743                   ;
  744 E842  7E          HL2DE:  LD      A,(HL)
  745 E843  12                  LD      (DE),A
  746 E844  23                  INC     HL
  747 E845  13                  INC     DE
  748 E846  05                  DEC     B
  749 E847  C2 E842             JP      NZ,HL2DE
  750 E84A  C9                  RET     
  751                   ;
  752                   ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
  753                   ;
  754 E84B  21 0080     EXTRACT:LD      HL,TBUFF
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  14
BDOS22  Z80

  755 E84E  81                  ADD     A,C
  756 E84F  CD E659             CALL    ADDHL
  757 E852  7E                  LD      A,(HL)
  758 E853  C9                  RET     
  759                   ;
  760                   ;  Check drive specified. If it means a change, then the new
  761                   ; drive will be selected. In any case, the drive byte of the
  762                   ; fcb will be set to null (means use current drive).
  763                   ;
  764 E854  AF          DSELECT:XOR     A               ;null out first byte of fcb.
  765 E855  32 EBCD             LD      (FCB),A
  766 E858  3A EBF0             LD      A,(CHGDRV)      ;a drive change indicated?
  767 E85B  B7                  OR      A
  768 E85C  C8                  RET     Z
  769 E85D  3D                  DEC     A               ;yes, is it the same as the current drive?
  770 E85E  21 EBEF             LD      HL,CDRIVE
  771 E861  BE                  CP      (HL)
  772 E862  C8                  RET     Z
  773 E863  C3 E4BD             JP      DSKSEL          ;no. Select it then.
  774                   ;
  775                   ;   Check the drive selection and reset it to the previous
  776                   ; drive if it was changed for the preceeding command.
  777                   ;
  778 E866  3A EBF0     RESETDR:LD      A,(CHGDRV)      ;drive change indicated?
  779 E869  B7                  OR      A
  780 E86A  C8                  RET     Z
  781 E86B  3D                  DEC     A               ;yes, was it a different drive?
  782 E86C  21 EBEF             LD      HL,CDRIVE
  783 E86F  BE                  CP      (HL)
  784 E870  C8                  RET     Z
  785 E871  3A EBEF             LD      A,(CDRIVE)      ;yes, re-select our old drive.
  786 E874  C3 E4BD             JP      DSKSEL
  787                   ;
  788                   ;**************************************************************
  789                   ;*
  790                   ;*           D I R E C T O R Y   C O M M A N D
  791                   ;*
  792                   ;**************************************************************
  793                   ;
  794 E877  CD E65E     DIRECT: CALL    CONVFST         ;convert file name.
  795 E87A  CD E854             CALL    DSELECT         ;select indicated drive.
  796 E87D  21 EBCE             LD      HL,FCB+1        ;was any file indicated?
  797 E880  7E                  LD      A,(HL)
  798 E881  FE 20               CP      ' '
  799 E883  C2 E88F             JP      NZ,DIRECT2
  800 E886  06 0B               LD      B,11            ;no. Fill field with '?' - same as *.*.
  801 E888  36 3F       DIRECT1:LD      (HL),'?'
  802 E88A  23                  INC     HL
  803 E88B  05                  DEC     B
  804 E88C  C2 E888             JP      NZ,DIRECT1
  805 E88F  1E 00       DIRECT2:LD      E,0             ;set initial cursor position.
  806 E891  D5                  PUSH    DE
  807 E892  CD E4E9             CALL    SRCHFCB         ;get first file name.
  808 E895  CC E7EA             CALL    Z,NONE          ;none found at all?
  809 E898  CA E91B     DIRECT3:JP      Z,DIRECT9       ;terminate if no more names.
  810 E89B  3A EBEE             LD      A,(RTNCODE)     ;get file's position in segment (0-3).
  811 E89E  0F                  RRCA    
  812 E89F  0F                  RRCA    
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  15
BDOS22  Z80

  813 E8A0  0F                  RRCA    
  814 E8A1  E6 60               AND     60H             ;(A)=position*32
  815 E8A3  4F                  LD      C,A
  816 E8A4  3E 0A               LD      A,10
  817 E8A6  CD E84B             CALL    EXTRACT         ;extract the tenth entry in fcb.
  818 E8A9  17                  RLA                     ;check system file status bit.
  819 E8AA  DA E90F             JP      C,DIRECT8       ;we don't list them.
  820 E8AD  D1                  POP     DE
  821 E8AE  7B                  LD      A,E             ;bump name count.
  822 E8AF  1C                  INC     E
  823 E8B0  D5                  PUSH    DE
  824 E8B1  E6 03               AND     03H             ;at end of line?
  825 E8B3  F5                  PUSH    AF
  826 E8B4  C2 E8CC             JP      NZ,DIRECT4
  827 E8B7  CD E498             CALL    CRLF            ;yes, end this line and start another.
  828 E8BA  C5                  PUSH    BC
  829 E8BB  CD E5D0             CALL    GETDSK          ;start line with ('A:').
  830 E8BE  C1                  POP     BC
  831 E8BF  C6 41               ADD     A,'A'
  832 E8C1  CD E492             CALL    PRINTB
  833 E8C4  3E 3A               LD      A,':'
  834 E8C6  CD E492             CALL    PRINTB
  835 E8C9  C3 E8D4             JP      DIRECT5
  836 E8CC  CD E4A2     DIRECT4:CALL    SPACE           ;add seperator between file names.
  837 E8CF  3E 3A               LD      A,':'
  838 E8D1  CD E492             CALL    PRINTB
  839 E8D4  CD E4A2     DIRECT5:CALL    SPACE
  840 E8D7  06 01               LD      B,1             ;'extract' each file name character at a time.
  841 E8D9  78          DIRECT6:LD      A,B
  842 E8DA  CD E84B             CALL    EXTRACT
  843 E8DD  E6 7F               AND     7FH             ;strip bit 7 (status bit).
  844 E8DF  FE 20               CP      ' '             ;are we at the end of the name?
  845 E8E1  C2 E8F9             JP      NZ,DRECT65
  846 E8E4  F1                  POP     AF              ;yes, don't print spaces at the end of a line.
  847 E8E5  F5                  PUSH    AF
  848 E8E6  FE 03               CP      3
  849 E8E8  C2 E8F7             JP      NZ,DRECT63
  850 E8EB  3E 09               LD      A,9             ;first check for no extension.
  851 E8ED  CD E84B             CALL    EXTRACT
  852 E8F0  E6 7F               AND     7FH
  853 E8F2  FE 20               CP      ' '
  854 E8F4  CA E90E             JP      Z,DIRECT7       ;don't print spaces.
  855 E8F7  3E 20       DRECT63:LD      A,' '           ;else print them.
  856 E8F9  CD E492     DRECT65:CALL    PRINTB
  857 E8FC  04                  INC     B               ;bump to next character psoition.
  858 E8FD  78                  LD      A,B
  859 E8FE  FE 0C               CP      12              ;end of the name?
  860 E900  D2 E90E             JP      NC,DIRECT7
  861 E903  FE 09               CP      9               ;nope, starting extension?
  862 E905  C2 E8D9             JP      NZ,DIRECT6
  863 E908  CD E4A2             CALL    SPACE           ;yes, add seperating space.
  864 E90B  C3 E8D9             JP      DIRECT6
  865 E90E  F1          DIRECT7:POP     AF              ;get the next file name.
  866 E90F  CD E5C2     DIRECT8:CALL    CHKCON          ;first check console, quit on anything.
  867 E912  C2 E91B             JP      NZ,DIRECT9
  868 E915  CD E4E4             CALL    SRCHNXT         ;get next name.
  869 E918  C3 E898             JP      DIRECT3         ;and continue with our list.
  870 E91B  D1          DIRECT9:POP     DE              ;restore the stack and return to command level.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  16
BDOS22  Z80

  871 E91C  C3 EB86             JP      GETBACK
  872                   ;
  873                   ;**************************************************************
  874                   ;*
  875                   ;*                E R A S E   C O M M A N D
  876                   ;*
  877                   ;**************************************************************
  878                   ;
  879 E91F  CD E65E     ERASE:  CALL    CONVFST         ;convert file name.
  880 E922  FE 0B               CP      11              ;was '*.*' entered?
  881 E924  C2 E942             JP      NZ,ERASE1
  882 E927  01 E952             LD      BC,YESNO        ;yes, ask for confirmation.
  883 E92A  CD E4A7             CALL    PLINE
  884 E92D  CD E539             CALL    GETINP
  885 E930  21 E407             LD      HL,INBUFF+1
  886 E933  35                  DEC     (HL)            ;must be exactly 'y'.
  887 E934  C2 E782             JP      NZ,CMMND1
  888 E937  23                  INC     HL
  889 E938  7E                  LD      A,(HL)
  890 E939  FE 59               CP      'Y'
  891 E93B  C2 E782             JP      NZ,CMMND1
  892 E93E  23                  INC     HL
  893 E93F  22 E488             LD      (INPOINT),HL    ;save input line pointer.
  894 E942  CD E854     ERASE1: CALL    DSELECT         ;select desired disk.
  895 E945  11 EBCD             LD      DE,FCB
  896 E948  CD E4EF             CALL    DELETE          ;delete the file.
  897 E94B  3C                  INC     A
  898 E94C  CC E7EA             CALL    Z,NONE          ;not there?
  899 E94F  C3 EB86             JP      GETBACK         ;return to command level now.
  900 E952  41 6C 6C 20 YESNO:   DB     "All (y/n)?"
  901 E95C  00                   DB     0
  902                   ;
  903                   ;**************************************************************
  904                   ;*
  905                   ;*            T Y P E   C O M M A N D
  906                   ;*
  907                   ;**************************************************************
  908                   ;
  909 E95D  CD E65E     TYPE:   CALL    CONVFST         ;convert file name.
  910 E960  C2 E609             JP      NZ,SYNERR       ;wild cards not allowed.
  911 E963  CD E854             CALL    DSELECT         ;select indicated drive.
  912 E966  CD E4D0             CALL    OPENFCB         ;open the file.
  913 E969  CA E9A7             JP      Z,TYPE5         ;not there?
  914 E96C  CD E498             CALL    CRLF            ;ok, start a new line on the screen.
  915 E96F  21 EBF1             LD      HL,NBYTES       ;initialize byte counter.
  916 E972  36 FF               LD      (HL),0FFH       ;set to read first sector.
  917 E974  21 EBF1     TYPE1:  LD      HL,NBYTES
  918 E977  7E          TYPE2:  LD      A,(HL)          ;have we written the entire sector?
  919 E978  FE 80               CP      128
  920 E97A  DA E987             JP      C,TYPE3
  921 E97D  E5                  PUSH    HL              ;yes, read in the next one.
  922 E97E  CD E4FE             CALL    READFCB
  923 E981  E1                  POP     HL
  924 E982  C2 E9A0             JP      NZ,TYPE4        ;end or error?
  925 E985  AF                  XOR     A               ;ok, clear byte counter.
  926 E986  77                  LD      (HL),A
  927 E987  34          TYPE3:  INC     (HL)            ;count this byte.
  928 E988  21 0080             LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  17
BDOS22  Z80

  929 E98B  CD E659             CALL    ADDHL
  930 E98E  7E                  LD      A,(HL)
  931 E98F  FE 1A               CP      CNTRLZ          ;end of file mark?
  932 E991  CA EB86             JP      Z,GETBACK
  933 E994  CD E48C             CALL    PRINT           ;no, print it.
  934 E997  CD E5C2             CALL    CHKCON          ;check console, quit if anything ready.
  935 E99A  C2 EB86             JP      NZ,GETBACK
  936 E99D  C3 E974             JP      TYPE1
  937                   ;
  938                   ;   Get here on an end of file or read error.
  939                   ;
  940 E9A0  3D          TYPE4:  DEC     A               ;read error?
  941 E9A1  CA EB86             JP      Z,GETBACK
  942 E9A4  CD E7D9             CALL    RDERROR         ;yes, print message.
  943 E9A7  CD E866     TYPE5:  CALL    RESETDR         ;and reset proper drive
  944 E9AA  C3 E609             JP      SYNERR          ;now print file name with problem.
  945                   ;
  946                   ;**************************************************************
  947                   ;*
  948                   ;*            S A V E   C O M M A N D
  949                   ;*
  950                   ;**************************************************************
  951                   ;
  952 E9AD  CD E7F8     SAVE:   CALL    DECODE          ;get numeric number that follows SAVE.
  953 E9B0  F5                  PUSH    AF              ;save number of pages to write.
  954 E9B1  CD E65E             CALL    CONVFST         ;convert file name.
  955 E9B4  C2 E609             JP      NZ,SYNERR       ;wild cards not allowed.
  956 E9B7  CD E854             CALL    DSELECT         ;select specified drive.
  957 E9BA  11 EBCD             LD      DE,FCB          ;now delete this file.
  958 E9BD  D5                  PUSH    DE
  959 E9BE  CD E4EF             CALL    DELETE
  960 E9C1  D1                  POP     DE
  961 E9C2  CD E509             CALL    CREATE          ;and create it again.
  962 E9C5  CA E9FB             JP      Z,SAVE3         ;can't create?
  963 E9C8  AF                  XOR     A               ;clear record number byte.
  964 E9C9  32 EBED             LD      (FCB+32),A
  965 E9CC  F1                  POP     AF              ;convert pages to sectors.
  966 E9CD  6F                  LD      L,A
  967 E9CE  26 00               LD      H,0
  968 E9D0  29                  ADD     HL,HL           ;(HL)=number of sectors to write.
  969 E9D1  11 0100             LD      DE,TBASE        ;and we start from here.
  970 E9D4  7C          SAVE1:  LD      A,H             ;done yet?
  971 E9D5  B5                  OR      L
  972 E9D6  CA E9F1             JP      Z,SAVE2
  973 E9D9  2B                  DEC     HL              ;nope, count this and compute the start
  974 E9DA  E5                  PUSH    HL              ;of the next 128 byte sector.
  975 E9DB  21 0080             LD      HL,128
  976 E9DE  19                  ADD     HL,DE
  977 E9DF  E5                  PUSH    HL              ;save it and set the transfer address.
  978 E9E0  CD E5D8             CALL    DMASET
  979 E9E3  11 EBCD             LD      DE,FCB          ;write out this sector now.
  980 E9E6  CD E504             CALL    WRTREC
  981 E9E9  D1                  POP     DE              ;reset (DE) to the start of the last sector.
  982 E9EA  E1                  POP     HL              ;restore sector count.
  983 E9EB  C2 E9FB             JP      NZ,SAVE3        ;write error?
  984 E9EE  C3 E9D4             JP      SAVE1
  985                   ;
  986                   ;   Get here after writing all of the file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  18
BDOS22  Z80

  987                   ;
  988 E9F1  11 EBCD     SAVE2:  LD      DE,FCB          ;now close the file.
  989 E9F4  CD E4DA             CALL    CLOSE
  990 E9F7  3C                  INC     A               ;did it close ok?
  991 E9F8  C2 EA01             JP      NZ,SAVE4
  992                   ;
  993                   ;   Print out error message (no space).
  994                   ;
  995 E9FB  01 EA07     SAVE3:  LD      BC,NOSPACE
  996 E9FE  CD E4A7             CALL    PLINE
  997 EA01  CD E5D5     SAVE4:  CALL    STDDMA          ;reset the standard dma address.
  998 EA04  C3 EB86             JP      GETBACK
  999 EA07  4E 6F 20 73 NOSPACE: DB     "No space"
 1000 EA0F  00                   DB     0
 1001                   ;
 1002                   ;**************************************************************
 1003                   ;*
 1004                   ;*           R E N A M E   C O M M A N D
 1005                   ;*
 1006                   ;**************************************************************
 1007                   ;
 1008 EA10  CD E65E     RENAME: CALL    CONVFST         ;convert first file name.
 1009 EA13  C2 E609             JP      NZ,SYNERR       ;wild cards not allowed.
 1010 EA16  3A EBF0             LD      A,(CHGDRV)      ;remember any change in drives specified.
 1011 EA19  F5                  PUSH    AF
 1012 EA1A  CD E854             CALL    DSELECT         ;and select this drive.
 1013 EA1D  CD E4E9             CALL    SRCHFCB         ;is this file present?
 1014 EA20  C2 EA79             JP      NZ,RENAME6      ;yes, print error message.
 1015 EA23  21 EBCD             LD      HL,FCB          ;yes, move this name into second slot.
 1016 EA26  11 EBDD             LD      DE,FCB+16
 1017 EA29  06 10               LD      B,16
 1018 EA2B  CD E842             CALL    HL2DE
 1019 EA2E  2A E488             LD      HL,(INPOINT)    ;get input pointer.
 1020 EA31  EB                  EX      DE,HL
 1021 EA32  CD E64F             CALL    NONBLANK        ;get next non blank character.
 1022 EA35  FE 3D               CP      '='             ;only allow an '=' or '_' seperator.
 1023 EA37  CA EA3F             JP      Z,RENAME1
 1024 EA3A  FE 5F               CP      '_'
 1025 EA3C  C2 EA73             JP      NZ,RENAME5
 1026 EA3F  EB          RENAME1:EX      DE,HL
 1027 EA40  23                  INC     HL              ;ok, skip seperator.
 1028 EA41  22 E488             LD      (INPOINT),HL    ;save input line pointer.
 1029 EA44  CD E65E             CALL    CONVFST         ;convert this second file name now.
 1030 EA47  C2 EA73             JP      NZ,RENAME5      ;again, no wild cards.
 1031 EA4A  F1                  POP     AF              ;if a drive was specified, then it
 1032 EA4B  47                  LD      B,A             ;must be the same as before.
 1033 EA4C  21 EBF0             LD      HL,CHGDRV
 1034 EA4F  7E                  LD      A,(HL)
 1035 EA50  B7                  OR      A
 1036 EA51  CA EA59             JP      Z,RENAME2
 1037 EA54  B8                  CP      B
 1038 EA55  70                  LD      (HL),B
 1039 EA56  C2 EA73             JP      NZ,RENAME5      ;they were different, error.
 1040 EA59  70          RENAME2:LD      (HL),B          ;       reset as per the first file specification.
 1041 EA5A  AF                  XOR     A
 1042 EA5B  32 EBCD             LD      (FCB),A         ;clear the drive byte of the fcb.
 1043 EA5E  CD E4E9     RENAME3:CALL    SRCHFCB         ;and go look for second file.
 1044 EA61  CA EA6D             JP      Z,RENAME4       ;doesn't exist?
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  19
BDOS22  Z80

 1045 EA64  11 EBCD             LD      DE,FCB
 1046 EA67  CD E50E             CALL    RENAM           ;ok, rename the file.
 1047 EA6A  C3 EB86             JP      GETBACK
 1048                   ;
 1049                   ;   Process rename errors here.
 1050                   ;
 1051 EA6D  CD E7EA     RENAME4:CALL    NONE            ;file not there.
 1052 EA70  C3 EB86             JP      GETBACK
 1053 EA73  CD E866     RENAME5:CALL    RESETDR         ;bad command format.
 1054 EA76  C3 E609             JP      SYNERR
 1055 EA79  01 EA82     RENAME6:LD      BC,EXISTS       ;destination file already exists.
 1056 EA7C  CD E4A7             CALL    PLINE
 1057 EA7F  C3 EB86             JP      GETBACK
 1058 EA82  46 69 6C 65 EXISTS:  DB     "File exists"
 1059 EA8D  00                   DB     0
 1060                   ;
 1061                   ;**************************************************************
 1062                   ;*
 1063                   ;*             U S E R   C O M M A N D
 1064                   ;*
 1065                   ;**************************************************************
 1066                   ;
 1067 EA8E  CD E7F8     USER:   CALL    DECODE          ;get numeric value following command.
 1068 EA91  FE 10               CP      16              ;legal user number?
 1069 EA93  D2 E609             JP      NC,SYNERR
 1070 EA96  5F                  LD      E,A             ;yes but is there anything else?
 1071 EA97  3A EBCE             LD      A,(FCB+1)
 1072 EA9A  FE 20               CP      ' '
 1073 EA9C  CA E609             JP      Z,SYNERR        ;yes, that is not allowed.
 1074 EA9F  CD E515             CALL    GETSETUC        ;ok, set user code.
 1075 EAA2  C3 EB89             JP      GETBACK1
 1076                   ;
 1077                   ;**************************************************************
 1078                   ;*
 1079                   ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
 1080                   ;*
 1081                   ;**************************************************************
 1082                   ;
 1083 EAA5  CD E5F5     UNKNOWN:CALL    VERIFY          ;check for valid system (why?).
 1084 EAA8  3A EBCE             LD      A,(FCB+1)       ;anything to execute?
 1085 EAAB  FE 20               CP      ' '
 1086 EAAD  C2 EAC4             JP      NZ,UNKWN1
 1087 EAB0  3A EBF0             LD      A,(CHGDRV)      ;nope, only a drive change?
 1088 EAB3  B7                  OR      A
 1089 EAB4  CA EB89             JP      Z,GETBACK1      ;neither???
 1090 EAB7  3D                  DEC     A
 1091 EAB8  32 EBEF             LD      (CDRIVE),A      ;ok, store new drive.
 1092 EABB  CD E529             CALL    MOVECD          ;set (TDRIVE) also.
 1093 EABE  CD E4BD             CALL    DSKSEL          ;and select this drive.
 1094 EAC1  C3 EB89             JP      GETBACK1        ;then return.
 1095                   ;
 1096                   ;   Here a file name was typed. Prepare to execute it.
 1097                   ;
 1098 EAC4  11 EBD6     UNKWN1: LD      DE,FCB+9        ;an extension specified?
 1099 EAC7  1A                  LD      A,(DE)
 1100 EAC8  FE 20               CP      ' '
 1101 EACA  C2 E609             JP      NZ,SYNERR       ;yes, not allowed.
 1102 EACD  D5          UNKWN2: PUSH    DE
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  20
BDOS22  Z80

 1103 EACE  CD E854             CALL    DSELECT         ;select specified drive.
 1104 EAD1  D1                  POP     DE
 1105 EAD2  21 EB83             LD      HL,COMFILE      ;set the extension to 'COM'.
 1106 EAD5  CD E840             CALL    MOVE3
 1107 EAD8  CD E4D0             CALL    OPENFCB         ;and open this file.
 1108 EADB  CA EB6B             JP      Z,UNKWN9        ;not present?
 1109                   ;
 1110                   ;   Load in the program.
 1111                   ;
 1112 EADE  21 0100             LD      HL,TBASE        ;store the program starting here.
 1113 EAE1  E5          UNKWN3: PUSH    HL
 1114 EAE2  EB                  EX      DE,HL
 1115 EAE3  CD E5D8             CALL    DMASET          ;set transfer address.
 1116 EAE6  11 EBCD             LD      DE,FCB          ;and read the next record.
 1117 EAE9  CD E4F9             CALL    RDREC
 1118 EAEC  C2 EB01             JP      NZ,UNKWN4       ;end of file or read error?
 1119 EAEF  E1                  POP     HL              ;nope, bump pointer for next sector.
 1120 EAF0  11 0080             LD      DE,128
 1121 EAF3  19                  ADD     HL,DE
 1122 EAF4  11 E400             LD      DE,CBASE        ;enough room for the whole file?
 1123 EAF7  7D                  LD      A,L
 1124 EAF8  93                  SUB     E
 1125 EAF9  7C                  LD      A,H
 1126 EAFA  9A                  SBC     A,D
 1127 EAFB  D2 EB71             JP      NC,UNKWN0       ;no, it can't fit.
 1128 EAFE  C3 EAE1             JP      UNKWN3
 1129                   ;
 1130                   ;   Get here after finished reading.
 1131                   ;
 1132 EB01  E1          UNKWN4: POP     HL
 1133 EB02  3D                  DEC     A               ;normal end of file?
 1134 EB03  C2 EB71             JP      NZ,UNKWN0
 1135 EB06  CD E866             CALL    RESETDR         ;yes, reset previous drive.
 1136 EB09  CD E65E             CALL    CONVFST         ;convert the first file name that follows
 1137 EB0C  21 EBF0             LD      HL,CHGDRV       ;command name.
 1138 EB0F  E5                  PUSH    HL
 1139 EB10  7E                  LD      A,(HL)          ;set drive code in default fcb.
 1140 EB11  32 EBCD             LD      (FCB),A
 1141 EB14  3E 10               LD      A,16            ;put second name 16 bytes later.
 1142 EB16  CD E660             CALL    CONVERT         ;convert second file name.
 1143 EB19  E1                  POP     HL
 1144 EB1A  7E                  LD      A,(HL)          ;and set the drive for this second file.
 1145 EB1B  32 EBDD             LD      (FCB+16),A
 1146 EB1E  AF                  XOR     A               ;clear record byte in fcb.
 1147 EB1F  32 EBED             LD      (FCB+32),A
 1148 EB22  11 005C             LD      DE,TFCB         ;move it into place at(005Ch).
 1149 EB25  21 EBCD             LD      HL,FCB
 1150 EB28  06 21               LD      B,33
 1151 EB2A  CD E842             CALL    HL2DE
 1152 EB2D  21 E408             LD      HL,INBUFF+2     ;now move the remainder of the input
 1153 EB30  7E          UNKWN5: LD      A,(HL)          ;line down to (0080h). Look for a non blank.
 1154 EB31  B7                  OR      A               ;or a null.
 1155 EB32  CA EB3E             JP      Z,UNKWN6
 1156 EB35  FE 20               CP      ' '
 1157 EB37  CA EB3E             JP      Z,UNKWN6
 1158 EB3A  23                  INC     HL
 1159 EB3B  C3 EB30             JP      UNKWN5
 1160                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  21
BDOS22  Z80

 1161                   ;   Do the line move now. It ends in a null byte.
 1162                   ;
 1163 EB3E  06 00       UNKWN6: LD      B,0             ;keep a character count.
 1164 EB40  11 0081             LD      DE,TBUFF+1      ;data gets put here.
 1165 EB43  7E          UNKWN7: LD      A,(HL)          ;move it now.
 1166 EB44  12                  LD      (DE),A
 1167 EB45  B7                  OR      A
 1168 EB46  CA EB4F             JP      Z,UNKWN8
 1169 EB49  04                  INC     B
 1170 EB4A  23                  INC     HL
 1171 EB4B  13                  INC     DE
 1172 EB4C  C3 EB43             JP      UNKWN7
 1173 EB4F  78          UNKWN8: LD      A,B             ;now store the character count.
 1174 EB50  32 0080             LD      (TBUFF),A
 1175 EB53  CD E498             CALL    CRLF            ;clean up the screen.
 1176 EB56  CD E5D5             CALL    STDDMA          ;set standard transfer address.
 1177 EB59  CD E51A             CALL    SETCDRV         ;reset current drive.
 1178 EB5C  CD 0100             CALL    TBASE           ;and execute the program.
 1179                   ;
 1180                   ;   Transiant programs return here (or reboot).
 1181                   ;
 1182 EB5F  31 EBAB             LD      SP,BATCH        ;set stack first off.
 1183 EB62  CD E529             CALL    MOVECD          ;move current drive into place (TDRIVE).
 1184 EB65  CD E4BD             CALL    DSKSEL          ;and reselect it.
 1185 EB68  C3 E782             JP      CMMND1          ;back to comand mode.
 1186                   ;
 1187                   ;   Get here if some error occured.
 1188                   ;
 1189 EB6B  CD E866     UNKWN9: CALL    RESETDR         ;inproper format.
 1190 EB6E  C3 E609             JP      SYNERR
 1191 EB71  01 EB7A     UNKWN0: LD      BC,BADLOAD      ;read error or won't fit.
 1192 EB74  CD E4A7             CALL    PLINE
 1193 EB77  C3 EB86             JP      GETBACK
 1194 EB7A  42 61 64 20 BADLOAD: DB     "Bad load"
 1195 EB82  00                   DB     0
 1196 EB83  43 4F 4D    COMFILE: DB     "COM"           ;command file extension.
 1197                   ;
 1198                   ;   Get here to return to command level. We will reset the
 1199                   ; previous active drive and then either return to command
 1200                   ; level directly or print error message and then return.
 1201                   ;
 1202 EB86  CD E866     GETBACK:CALL    RESETDR         ;reset previous drive.
 1203 EB89  CD E65E     GETBACK1: CALL  CONVFST         ;convert first name in (FCB).
 1204 EB8C  3A EBCE             LD      A,(FCB+1)       ;if this was just a drive change request,
 1205 EB8F  D6 20               SUB     ' '             ;make sure it was valid.
 1206 EB91  21 EBF0             LD      HL,CHGDRV
 1207 EB94  B6                  OR      (HL)
 1208 EB95  C2 E609             JP      NZ,SYNERR
 1209 EB98  C3 E782             JP      CMMND1          ;ok, return to command level.
 1210                   ;
 1211                   ;   ccp stack area.
 1212                   ;
 1213 EB9B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1214         EBAB      CCPSTACK  EQU   $       ;end of ccp stack area.
 1215                   ;
 1216                   ;   Batch (or SUBMIT) processing information storage.
 1217                   ;
 1218 EBAB  00          BATCH:   DB     0               ;batch mode flag (0=not active).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  22
BDOS22  Z80

 1219 EBAC  00          BATCHFCB:  DB   0,
 1220 EBAD  24 24 24 20          DB   "$$$     SUB"
 1221 EBB8  00 00 00 00          DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1222                   ;
 1223                   ;   File control block setup by the CCP.
 1224                   ;
 1225 EBCD  00          FCB:     DB     0
 1226 EBCE  20 20 20 20          DB     "           "
 1227 EBD9  00 00 00 00          DB     0,0,0,0,0
 1228 EBDE  20 20 20 20          DB     "           "
 1229 EBE9  00 00 00 00          DB     0,0,0,0,0
 1230 EBEE  00          RTNCODE: DB     0               ;status returned from bdos call.
 1231 EBEF  00          CDRIVE:  DB     0               ;currently active drive.
 1232 EBF0  00          CHGDRV:  DB     0               ;change in drives flag (0=no change).
 1233 EBF1  0000        NBYTES:  DW     0               ;byte counter used by TYPE.
 1234                   ;
 1235                   ;   Room for expansion?
 1236                   ;
 1237 EBF3  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0
 1238                   ;
 1239                   ;   Note that the following six bytes must match those at
 1240                   ; (PATTRN1) or cp/m will HALT. Why?
 1241                   ;
 1242 EC00  00 16 00 00 PATTRN2: DB     0,22,0,0,0,0    ;(* serial number bytes *).
 1243                   ;
 1244                   ;**************************************************************
 1245                   ;*
 1246                   ;*                    B D O S   E N T R Y
 1247                   ;*
 1248                   ;**************************************************************
 1249                   ;
 1250 EC06  C3 EC11     FBASE:  JP      FBASE1
 1251                   ;
 1252                   ;   Bdos error table.
 1253                   ;
 1254 EC09  EC99        BADSCTR: DW     ERROR1          ;bad sector on read or write.
 1255 EC0B  ECA5        BADSLCT: DW     ERROR2          ;bad disk select.
 1256 EC0D  ECAB        RODISK:  DW     ERROR3          ;disk is read only.
 1257 EC0F  ECB1        ROFILE:  DW     ERROR4          ;file is read only.
 1258                   ;
 1259                   ;   Entry into bdos. (DE) or (E) are the parameters passed. The
 1260                   ; function number desired is in register (C).
 1261                   ;
 1262 EC11  EB          FBASE1: EX      DE,HL           ;save the (DE) parameters.
 1263 EC12  22 EF43             LD      (PARAMS),HL
 1264 EC15  EB                  EX      DE,HL
 1265 EC16  7B                  LD      A,E             ;and save register (E) in particular.
 1266 EC17  32 F9D6             LD      (EPARAM),A
 1267 EC1A  21 0000             LD      HL,0
 1268 EC1D  22 EF45             LD      (STATUS),HL     ;clear return status.
 1269 EC20  39                  ADD     HL,SP
 1270 EC21  22 EF0F             LD      (USRSTACK),HL   ;save users stack pointer.
 1271 EC24  31 EF41             LD      SP,STKAREA      ;and set our own.
 1272 EC27  AF                  XOR     A               ;clear auto select storage space.
 1273 EC28  32 F9E0             LD      (AUTOFLAG),A
 1274 EC2B  32 F9DE             LD      (AUTO),A
 1275 EC2E  21 F974             LD      HL,GOBACK       ;set return address.
 1276 EC31  E5                  PUSH    HL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  23
BDOS22  Z80

 1277 EC32  79                  LD      A,C             ;get function number.
 1278 EC33  FE 29               CP      NFUNCTS         ;valid function number?
 1279 EC35  D0                  RET     NC
 1280 EC36  4B                  LD      C,E             ;keep single register function here.
 1281 EC37  21 EC47             LD      HL,FUNCTNS      ;now look thru the function table.
 1282 EC3A  5F                  LD      E,A
 1283 EC3B  16 00               LD      D,0             ;(DE)=function number.
 1284 EC3D  19                  ADD     HL,DE
 1285 EC3E  19                  ADD     HL,DE           ;(HL)=(start of table)+2*(function number).
 1286 EC3F  5E                  LD      E,(HL)
 1287 EC40  23                  INC     HL
 1288 EC41  56                  LD      D,(HL)          ;now (DE)=address for this function.
 1289 EC42  2A EF43             LD      HL,(PARAMS)     ;retrieve parameters.
 1290 EC45  EB                  EX      DE,HL           ;now (DE) has the original parameters.
 1291 EC46  E9                  JP      (HL)            ;execute desired function.
 1292                   ;
 1293                   ;   BDOS function jump table.
 1294                   ;
 1295         0029      NFUNCTS  EQU    41              ;number of functions in followin table.
 1296                   ;
 1297 EC47  FA03  EEC8  FUNCTNS: DW     WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
 1298 EC57  EEF3  EEF8           DW     SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
 1299 EC67  F8A5  F8AB           DW     CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
 1300 EC75  F8F5  F8FE           DW     RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
 1301 EC85  F926  F92D           DW     GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
 1302 EC95  EF04  F99B           DW     RTN,WTSPECL
 1303                   ;
 1304                   ;   Bdos error message section.
 1305                   ;
 1306 EC99  21 ECCA     ERROR1: LD      HL,BADSEC       ;bad sector message.
 1307 EC9C  CD ECE5             CALL    PRTERR          ;print it and get a 1 char responce.
 1308 EC9F  FE 03               CP      CNTRLC          ;re-boot request (control-c)?
 1309 ECA1  CA 0000             JP      Z,0             ;yes.
 1310 ECA4  C9                  RET                     ;no, return to retry i/o function.
 1311                   ;
 1312 ECA5  21 ECD5     ERROR2: LD      HL,BADSEL       ;bad drive selected.
 1313 ECA8  C3 ECB4             JP      ERROR5
 1314                   ;
 1315 ECAB  21 ECE1     ERROR3: LD      HL,DISKRO       ;disk is read only.
 1316 ECAE  C3 ECB4             JP      ERROR5
 1317                   ;
 1318 ECB1  21 ECDC     ERROR4: LD      HL,FILERO       ;file is read only.
 1319                   ;
 1320 ECB4  CD ECE5     ERROR5: CALL    PRTERR
 1321 ECB7  C3 0000             JP      0               ;always reboot on these errors.
 1322                   ;
 1323 ECBA  42 64 6F 73 BDOSERR: DB     "Bdos Err On "
 1324 ECC6  20 3A 20 24 BDOSDRV: DB     " : $"
 1325 ECCA  42 61 64 20 BADSEC:  DB     "Bad Sector$"
 1326 ECD5  53 65 6C 65 BADSEL:  DB     "Select$"
 1327 ECDC  46 69 6C 65 FILERO:  DB     "File "
 1328 ECE1  52 2F 4F 24 DISKRO:  DB     "R/O$"
 1329                   ;
 1330                   ;   Print bdos error message.
 1331                   ;
 1332 ECE5  E5          PRTERR: PUSH    HL              ;save second message pointer.
 1333 ECE6  CD EDC9             CALL    OUTCRLF         ;send (cr)(lf).
 1334 ECE9  3A EF42             LD      A,(ACTIVE)      ;get active drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  24
BDOS22  Z80

 1335 ECEC  C6 41               ADD     A,'A'           ;make ascii.
 1336 ECEE  32 ECC6             LD      (BDOSDRV),A     ;and put in message.
 1337 ECF1  01 ECBA             LD      BC,BDOSERR      ;and print it.
 1338 ECF4  CD EDD3             CALL    PRTMESG
 1339 ECF7  C1                  POP     BC              ;print second message line now.
 1340 ECF8  CD EDD3             CALL    PRTMESG
 1341                   ;
 1342                   ;   Get an input character. We will check our 1 character
 1343                   ; buffer first. This may be set by the console status routine.
 1344                   ;
 1345 ECFB  21 EF0E     GETCHAR:LD      HL,CHARBUF      ;check character buffer.
 1346 ECFE  7E                  LD      A,(HL)          ;anything present already?
 1347 ECFF  36 00               LD      (HL),0          ;...either case clear it.
 1348 ED01  B7                  OR      A
 1349 ED02  C0                  RET     NZ              ;yes, use it.
 1350 ED03  C3 FA09             JP      CONIN           ;nope, go get a character responce.
 1351                   ;
 1352                   ;   Input and echo a character.
 1353                   ;
 1354 ED06  CD ECFB     GETECHO:CALL    GETCHAR         ;input a character.
 1355 ED09  CD ED14             CALL    CHKCHAR         ;carriage control?
 1356 ED0C  D8                  RET     C               ;no, a regular control char so don't echo.
 1357 ED0D  F5                  PUSH    AF              ;ok, save character now.
 1358 ED0E  4F                  LD      C,A
 1359 ED0F  CD ED90             CALL    OUTCON          ;and echo it.
 1360 ED12  F1                  POP     AF              ;get character and return.
 1361 ED13  C9                  RET     
 1362                   ;
 1363                   ;   Check character in (A). Set the zero flag on a carriage
 1364                   ; control character and the carry flag on any other control
 1365                   ; character.
 1366                   ;
 1367 ED14  FE 0D       CHKCHAR:CP      CR              ;check for carriage return, line feed, backspace,
 1368 ED16  C8                  RET     Z               ;or a tab.
 1369 ED17  FE 0A               CP      LF
 1370 ED19  C8                  RET     Z
 1371 ED1A  FE 09               CP      TAB
 1372 ED1C  C8                  RET     Z
 1373 ED1D  FE 08               CP      BS
 1374 ED1F  C8                  RET     Z
 1375 ED20  FE 20               CP      ' '             ;other control char? Set carry flag.
 1376 ED22  C9                  RET     
 1377                   ;
 1378                   ;   Check the console during output. Halt on a control-s, then
 1379                   ; reboot on a control-c. If anything else is ready, clear the
 1380                   ; zero flag and return (the calling routine may want to do
 1381                   ; something).
 1382                   ;
 1383 ED23  3A EF0E     CKCONSOL: LD    A,(CHARBUF)     ;check buffer.
 1384 ED26  B7                  OR      A               ;if anything, just return without checking.
 1385 ED27  C2 ED45             JP      NZ,CKCON2
 1386 ED2A  CD FA06             CALL    CONST           ;nothing in buffer. Check console.
 1387 ED2D  E6 01               AND     01H             ;look at bit 0.
 1388 ED2F  C8                  RET     Z               ;return if nothing.
 1389 ED30  CD FA09             CALL    CONIN           ;ok, get it.
 1390 ED33  FE 13               CP      CNTRLS          ;if not control-s, return with zero cleared.
 1391 ED35  C2 ED42             JP      NZ,CKCON1
 1392 ED38  CD FA09             CALL    CONIN           ;halt processing until another char
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  25
BDOS22  Z80

 1393 ED3B  FE 03               CP      CNTRLC          ;is typed. Control-c?
 1394 ED3D  CA 0000             JP      Z,0             ;yes, reboot now.
 1395 ED40  AF                  XOR     A               ;no, just pretend nothing was ever ready.
 1396 ED41  C9                  RET     
 1397 ED42  32 EF0E     CKCON1: LD      (CHARBUF),A     ;save character in buffer for later processing.
 1398 ED45  3E 01       CKCON2: LD      A,1             ;set (A) to non zero to mean something is ready.
 1399 ED47  C9                  RET     
 1400                   ;
 1401                   ;   Output (C) to the screen. If the printer flip-flop flag
 1402                   ; is set, we will send character to printer also. The console
 1403                   ; will be checked in the process.
 1404                   ;
 1405 ED48  3A EF0A     OUTCHAR:LD      A,(OUTFLAG)     ;check output flag.
 1406 ED4B  B7                  OR      A               ;anything and we won't generate output.
 1407 ED4C  C2 ED62             JP      NZ,OUTCHR1
 1408 ED4F  C5                  PUSH    BC
 1409 ED50  CD ED23             CALL    CKCONSOL        ;check console (we don't care whats there).
 1410 ED53  C1                  POP     BC
 1411 ED54  C5                  PUSH    BC
 1412 ED55  CD FA0C             CALL    CONOUT          ;output (C) to the screen.
 1413 ED58  C1                  POP     BC
 1414 ED59  C5                  PUSH    BC
 1415 ED5A  3A EF0D             LD      A,(PRTFLAG)     ;check printer flip-flop flag.
 1416 ED5D  B7                  OR      A
 1417 ED5E  C4 FA0F             CALL    NZ,LIST         ;print it also if non-zero.
 1418 ED61  C1                  POP     BC
 1419 ED62  79          OUTCHR1:LD      A,C             ;update cursors position.
 1420 ED63  21 EF0C             LD      HL,CURPOS
 1421 ED66  FE 7F               CP      DEL             ;rubouts don't do anything here.
 1422 ED68  C8                  RET     Z
 1423 ED69  34                  INC     (HL)            ;bump line pointer.
 1424 ED6A  FE 20               CP      ' '             ;and return if a normal character.
 1425 ED6C  D0                  RET     NC
 1426 ED6D  35                  DEC     (HL)            ;restore and check for the start of the line.
 1427 ED6E  7E                  LD      A,(HL)
 1428 ED6F  B7                  OR      A
 1429 ED70  C8                  RET     Z               ;ingnore control characters at the start of the line.
 1430 ED71  79                  LD      A,C
 1431 ED72  FE 08               CP      BS              ;is it a backspace?
 1432 ED74  C2 ED79             JP      NZ,OUTCHR2
 1433 ED77  35                  DEC     (HL)            ;yes, backup pointer.
 1434 ED78  C9                  RET     
 1435 ED79  FE 0A       OUTCHR2:CP      LF              ;is it a line feed?
 1436 ED7B  C0                  RET     NZ              ;ignore anything else.
 1437 ED7C  36 00               LD      (HL),0          ;reset pointer to start of line.
 1438 ED7E  C9                  RET     
 1439                   ;
 1440                   ;   Output (A) to the screen. If it is a control character
 1441                   ; (other than carriage control), use ^x format.
 1442                   ;
 1443 ED7F  79          SHOWIT: LD      A,C
 1444 ED80  CD ED14             CALL    CHKCHAR         ;check character.
 1445 ED83  D2 ED90             JP      NC,OUTCON       ;not a control, use normal output.
 1446 ED86  F5                  PUSH    AF
 1447 ED87  0E 5E               LD      C,'^'           ;for a control character, preceed it with '^'.
 1448 ED89  CD ED48             CALL    OUTCHAR
 1449 ED8C  F1                  POP     AF
 1450 ED8D  F6 40               OR      '@'             ;and then use the letter equivelant.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  26
BDOS22  Z80

 1451 ED8F  4F                  LD      C,A
 1452                   ;
 1453                   ;   Function to output (C) to the console device and expand tabs
 1454                   ; if necessary.
 1455                   ;
 1456 ED90  79          OUTCON: LD      A,C
 1457 ED91  FE 09               CP      TAB             ;is it a tab?
 1458 ED93  C2 ED48             JP      NZ,OUTCHAR      ;use regular output.
 1459 ED96  0E 20       OUTCON1:LD      C,' '           ;yes it is, use spaces instead.
 1460 ED98  CD ED48             CALL    OUTCHAR
 1461 ED9B  3A EF0C             LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8
 1462                   
 1463 ED9E  E6 07               AND     07H             ;position.
 1464 EDA0  C2 ED96             JP      NZ,OUTCON1
 1465 EDA3  C9                  RET     
 1466                   ;
 1467                   ;   Echo a backspace character. Erase the prevoius character
 1468                   ; on the screen.
 1469                   ;
 1470 EDA4  CD EDAC     BACKUP: CALL    BACKUP1         ;backup the screen 1 place.
 1471 EDA7  0E 20               LD      C,' '           ;then blank that character.
 1472 EDA9  CD FA0C             CALL    CONOUT
 1473 EDAC  0E 08       BACKUP1:LD      C,BS            ;then back space once more.
 1474 EDAE  C3 FA0C             JP      CONOUT
 1475                   ;
 1476                   ;   Signal a deleted line. Print a '#' at the end and start
 1477                   ; over.
 1478                   ;
 1479 EDB1  0E 23       NEWLINE:LD      C,'#'
 1480 EDB3  CD ED48             CALL    OUTCHAR         ;print this.
 1481 EDB6  CD EDC9             CALL    OUTCRLF         ;start new line.
 1482 EDB9  3A EF0C     NEWLN1: LD      A,(CURPOS)      ;move the cursor to the starting position.
 1483 EDBC  21 EF0B             LD      HL,STARTING
 1484 EDBF  BE                  CP      (HL)
 1485 EDC0  D0                  RET     NC              ;there yet?
 1486 EDC1  0E 20               LD      C,' '
 1487 EDC3  CD ED48             CALL    OUTCHAR         ;nope, keep going.
 1488 EDC6  C3 EDB9             JP      NEWLN1
 1489                   ;
 1490                   ;   Output a (cr) (lf) to the console device (screen).
 1491                   ;
 1492 EDC9  0E 0D       OUTCRLF:LD      C,CR
 1493 EDCB  CD ED48             CALL    OUTCHAR
 1494 EDCE  0E 0A               LD      C,LF
 1495 EDD0  C3 ED48             JP      OUTCHAR
 1496                   ;
 1497                   ;   Print message pointed to by (BC). It will end with a '$'.
 1498                   ;
 1499 EDD3  0A          PRTMESG:LD      A,(BC)          ;check for terminating character.
 1500 EDD4  FE 24               CP      '$'
 1501 EDD6  C8                  RET     Z
 1502 EDD7  03                  INC     BC
 1503 EDD8  C5                  PUSH    BC              ;otherwise, bump pointer and print it.
 1504 EDD9  4F                  LD      C,A
 1505 EDDA  CD ED90             CALL    OUTCON
 1506 EDDD  C1                  POP     BC
 1507 EDDE  C3 EDD3             JP      PRTMESG
 1508                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  27
BDOS22  Z80

 1509                   ;   Function to execute a buffered read.
 1510                   ;
 1511 EDE1  3A EF0C     RDBUFF: LD      A,(CURPOS)      ;use present location as starting one.
 1512 EDE4  32 EF0B             LD      (STARTING),A
 1513 EDE7  2A EF43             LD      HL,(PARAMS)     ;get the maximum buffer space.
 1514 EDEA  4E                  LD      C,(HL)
 1515 EDEB  23                  INC     HL              ;point to first available space.
 1516 EDEC  E5                  PUSH    HL              ;and save.
 1517 EDED  06 00               LD      B,0             ;keep a character count.
 1518 EDEF  C5          RDBUF1: PUSH    BC
 1519 EDF0  E5                  PUSH    HL
 1520 EDF1  CD ECFB     RDBUF2: CALL    GETCHAR         ;get the next input character.
 1521 EDF4  E6 7F               AND     7FH             ;strip bit 7.
 1522 EDF6  E1                  POP     HL              ;reset registers.
 1523 EDF7  C1                  POP     BC
 1524 EDF8  FE 0D               CP      CR              ;en of the line?
 1525 EDFA  CA EEC1             JP      Z,RDBUF17
 1526 EDFD  FE 0A               CP      LF
 1527 EDFF  CA EEC1             JP      Z,RDBUF17
 1528 EE02  FE 08               CP      BS              ;how about a backspace?
 1529 EE04  C2 EE16             JP      NZ,RDBUF3
 1530 EE07  78                  LD      A,B             ;yes, but ignore at the beginning of the line.
 1531 EE08  B7                  OR      A
 1532 EE09  CA EDEF             JP      Z,RDBUF1
 1533 EE0C  05                  DEC     B               ;ok, update counter.
 1534 EE0D  3A EF0C             LD      A,(CURPOS)      ;if we backspace to the start of the line,
 1535 EE10  32 EF0A             LD      (OUTFLAG),A     ;treat as a cancel (control-x).
 1536 EE13  C3 EE70             JP      RDBUF10
 1537 EE16  FE 7F       RDBUF3: CP      DEL             ;user typed a rubout?
 1538 EE18  C2 EE26             JP      NZ,RDBUF4
 1539 EE1B  78                  LD      A,B             ;ignore at the start of the line.
 1540 EE1C  B7                  OR      A
 1541 EE1D  CA EDEF             JP      Z,RDBUF1
 1542 EE20  7E                  LD      A,(HL)          ;ok, echo the prevoius character.
 1543 EE21  05                  DEC     B               ;and reset pointers (counters).
 1544 EE22  2B                  DEC     HL
 1545 EE23  C3 EEA9             JP      RDBUF15
 1546 EE26  FE 05       RDBUF4: CP      CNTRLE          ;physical end of line?
 1547 EE28  C2 EE37             JP      NZ,RDBUF5
 1548 EE2B  C5                  PUSH    BC              ;yes, do it.
 1549 EE2C  E5                  PUSH    HL
 1550 EE2D  CD EDC9             CALL    OUTCRLF
 1551 EE30  AF                  XOR     A               ;and update starting position.
 1552 EE31  32 EF0B             LD      (STARTING),A
 1553 EE34  C3 EDF1             JP      RDBUF2
 1554 EE37  FE 10       RDBUF5: CP      CNTRLP          ;control-p?
 1555 EE39  C2 EE48             JP      NZ,RDBUF6
 1556 EE3C  E5                  PUSH    HL              ;yes, flip the print flag filp-flop byte.
 1557 EE3D  21 EF0D             LD      HL,PRTFLAG
 1558 EE40  3E 01               LD      A,1             ;PRTFLAG=1-PRTFLAG
 1559 EE42  96                  SUB     (HL)
 1560 EE43  77                  LD      (HL),A
 1561 EE44  E1                  POP     HL
 1562 EE45  C3 EDEF             JP      RDBUF1
 1563 EE48  FE 18       RDBUF6: CP      CNTRLX          ;control-x (cancel)?
 1564 EE4A  C2 EE5F             JP      NZ,RDBUF8
 1565 EE4D  E1                  POP     HL
 1566 EE4E  3A EF0B     RDBUF7: LD      A,(STARTING)    ;yes, backup the cursor to here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  28
BDOS22  Z80

 1567 EE51  21 EF0C             LD      HL,CURPOS
 1568 EE54  BE                  CP      (HL)
 1569 EE55  D2 EDE1             JP      NC,RDBUFF       ;done yet?
 1570 EE58  35                  DEC     (HL)            ;no, decrement pointer and output back up one space.
 1571 EE59  CD EDA4             CALL    BACKUP
 1572 EE5C  C3 EE4E             JP      RDBUF7
 1573 EE5F  FE 15       RDBUF8: CP      CNTRLU          ;cntrol-u (cancel line)?
 1574 EE61  C2 EE6B             JP      NZ,RDBUF9
 1575 EE64  CD EDB1             CALL    NEWLINE         ;start a new line.
 1576 EE67  E1                  POP     HL
 1577 EE68  C3 EDE1             JP      RDBUFF
 1578 EE6B  FE 12       RDBUF9: CP      CNTRLR          ;control-r?
 1579 EE6D  C2 EEA6             JP      NZ,RDBUF14
 1580 EE70  C5          RDBUF10:PUSH    BC              ;yes, start a new line and retype the old one.
 1581 EE71  CD EDB1             CALL    NEWLINE
 1582 EE74  C1                  POP     BC
 1583 EE75  E1                  POP     HL
 1584 EE76  E5                  PUSH    HL
 1585 EE77  C5                  PUSH    BC
 1586 EE78  78          RDBUF11:LD      A,B             ;done whole line yet?
 1587 EE79  B7                  OR      A
 1588 EE7A  CA EE8A             JP      Z,RDBUF12
 1589 EE7D  23                  INC     HL              ;nope, get next character.
 1590 EE7E  4E                  LD      C,(HL)
 1591 EE7F  05                  DEC     B               ;count it.
 1592 EE80  C5                  PUSH    BC
 1593 EE81  E5                  PUSH    HL
 1594 EE82  CD ED7F             CALL    SHOWIT          ;and display it.
 1595 EE85  E1                  POP     HL
 1596 EE86  C1                  POP     BC
 1597 EE87  C3 EE78             JP      RDBUF11
 1598 EE8A  E5          RDBUF12:PUSH    HL              ;done with line. If we were displaying
 1599 EE8B  3A EF0A             LD      A,(OUTFLAG)     ;then update cursor position.
 1600 EE8E  B7                  OR      A
 1601 EE8F  CA EDF1             JP      Z,RDBUF2
 1602 EE92  21 EF0C             LD      HL,CURPOS       ;because this line is shorter, we must
 1603 EE95  96                  SUB     (HL)            ;back up the cursor (not the screen however)
 1604 EE96  32 EF0A             LD      (OUTFLAG),A     ;some number of positions.
 1605 EE99  CD EDA4     RDBUF13:CALL    BACKUP          ;note that as long as (OUTFLAG) is non
 1606 EE9C  21 EF0A             LD      HL,OUTFLAG      ;zero, the screen will not be changed.
 1607 EE9F  35                  DEC     (HL)
 1608 EEA0  C2 EE99             JP      NZ,RDBUF13
 1609 EEA3  C3 EDF1             JP      RDBUF2          ;now just get the next character.
 1610                   ;
 1611                   ;   Just a normal character, put this in our buffer and echo.
 1612                   ;
 1613 EEA6  23          RDBUF14:INC     HL
 1614 EEA7  77                  LD      (HL),A          ;store character.
 1615 EEA8  04                  INC     B               ;and count it.
 1616 EEA9  C5          RDBUF15:PUSH    BC
 1617 EEAA  E5                  PUSH    HL
 1618 EEAB  4F                  LD      C,A             ;echo it now.
 1619 EEAC  CD ED7F             CALL    SHOWIT
 1620 EEAF  E1                  POP     HL
 1621 EEB0  C1                  POP     BC
 1622 EEB1  7E                  LD      A,(HL)          ;was it an abort request?
 1623 EEB2  FE 03               CP      CNTRLC          ;control-c abort?
 1624 EEB4  78                  LD      A,B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  29
BDOS22  Z80

 1625 EEB5  C2 EEBD             JP      NZ,RDBUF16
 1626 EEB8  FE 01               CP      1               ;only if at start of line.
 1627 EEBA  CA 0000             JP      Z,0
 1628 EEBD  B9          RDBUF16:CP      C               ;nope, have we filled the buffer?
 1629 EEBE  DA EDEF             JP      C,RDBUF1
 1630 EEC1  E1          RDBUF17:POP     HL              ;yes end the line and return.
 1631 EEC2  70                  LD      (HL),B
 1632 EEC3  0E 0D               LD      C,CR
 1633 EEC5  C3 ED48             JP      OUTCHAR         ;output (cr) and return.
 1634                   ;
 1635                   ;   Function to get a character from the console device.
 1636                   ;
 1637 EEC8  CD ED06     GETCON: CALL    GETECHO         ;get and echo.
 1638 EECB  C3 EF01             JP      SETSTAT         ;save status and return.
 1639                   ;
 1640                   ;   Function to get a character from the tape reader device.
 1641                   ;
 1642 EECE  CD FA15     GETRDR: CALL    READER          ;get a character from reader, set status and return.
 1643 EED1  C3 EF01             JP      SETSTAT
 1644                   ;
 1645                   ;  Function to perform direct console i/o. If (C) contains (FF)
 1646                   ; then this is an input request. If (C) contains (FE) then
 1647                   ; this is a status request. Otherwise we are to output (C).
 1648                   ;
 1649 EED4  79          DIRCIO: LD      A,C             ;test for (FF).
 1650 EED5  3C                  INC     A
 1651 EED6  CA EEE0             JP      Z,DIRC1
 1652 EED9  3C                  INC     A               ;test for (FE).
 1653 EEDA  CA FA06             JP      Z,CONST
 1654 EEDD  C3 FA0C             JP      CONOUT          ;just output (C).
 1655 EEE0  CD FA06     DIRC1:  CALL    CONST           ;this is an input request.
 1656 EEE3  B7                  OR      A
 1657 EEE4  CA F991             JP      Z,GOBACK1       ;not ready? Just return (directly).
 1658 EEE7  CD FA09             CALL    CONIN           ;yes, get character.
 1659 EEEA  C3 EF01             JP      SETSTAT         ;set status and return.
 1660                   ;
 1661                   ;   Function to return the i/o byte.
 1662                   ;
 1663 EEED  3A 0003     GETIOB: LD      A,(IOBYTE)
 1664 EEF0  C3 EF01             JP      SETSTAT
 1665                   ;
 1666                   ;   Function to set the i/o byte.
 1667                   ;
 1668 EEF3  21 0003     SETIOB: LD      HL,IOBYTE
 1669 EEF6  71                  LD      (HL),C
 1670 EEF7  C9                  RET     
 1671                   ;
 1672                   ;   Function to print the character string pointed to by (DE)
 1673                   ; on the console device. The string ends with a '$'.
 1674                   ;
 1675 EEF8  EB          PRTSTR: EX      DE,HL
 1676 EEF9  4D                  LD      C,L
 1677 EEFA  44                  LD      B,H             ;now (BC) points to it.
 1678 EEFB  C3 EDD3             JP      PRTMESG
 1679                   ;
 1680                   ;   Function to interigate the console device.
 1681                   ;
 1682 EEFE  CD ED23     GETCSTS:CALL    CKCONSOL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  30
BDOS22  Z80

 1683                   ;
 1684                   ;   Get here to set the status and return to the cleanup
 1685                   ; section. Then back to the user.
 1686                   ;
 1687 EF01  32 EF45     SETSTAT:LD      (STATUS),A
 1688 EF04  C9          RTN:    RET     
 1689                   ;
 1690                   ;   Set the status to 1 (read or write error code).
 1691                   ;
 1692 EF05  3E 01       IOERR1: LD      A,1
 1693 EF07  C3 EF01             JP      SETSTAT
 1694                   ;
 1695 EF0A  00          OUTFLAG: DB     0               ;output flag (non zero means no output).
 1696 EF0B  02          STARTING:  DB   2               ;starting position for cursor.
 1697 EF0C  00          CURPOS:  DB     0               ;cursor position (0=start of line).
 1698 EF0D  00          PRTFLAG: DB     0               ;printer flag (control-p toggle). List if non zero.
 1699 EF0E  00          CHARBUF: DB     0               ;single input character buffer.
 1700                   ;
 1701                   ;   Stack area for BDOS calls.
 1702                   ;
 1703 EF0F  0000        USRSTACK:  DW   0               ;save users stack pointer here.
 1704                   ;
 1705 EF11  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1706 EF29  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1707         EF41      STKAREA  EQU    $               ;end of stack area.
 1708                   ;
 1709 EF41  00          USERNO:  DB     0               ;current user number.
 1710 EF42  00          ACTIVE:  DB     0               ;currently active drive.
 1711 EF43  0000        PARAMS:  DW     0               ;save (DE) parameters here on entry.
 1712 EF45  0000        STATUS:  DW     0               ;status returned from bdos function.
 1713                   ;
 1714                   ;   Select error occured, jump to error routine.
 1715                   ;
 1716 EF47  21 EC0B     SLCTERR:LD      HL,BADSLCT
 1717                   ;
 1718                   ;   Jump to (HL) indirectly.
 1719                   ;
 1720 EF4A  5E          JUMPHL: LD      E,(HL)
 1721 EF4B  23                  INC     HL
 1722 EF4C  56                  LD      D,(HL)          ;now (DE) contain the desired address.
 1723 EF4D  EB                  EX      DE,HL
 1724 EF4E  E9                  JP      (HL)
 1725                   ;
 1726                   ;   Block move. (DE) to (HL), (C) bytes total.
 1727                   ;
 1728 EF4F  0C          DE2HL:  INC     C               ;is count down to zero?
 1729 EF50  0D          DE2HL1: DEC     C
 1730 EF51  C8                  RET     Z               ;yes, we are done.
 1731 EF52  1A                  LD      A,(DE)          ;no, move one more byte.
 1732 EF53  77                  LD      (HL),A
 1733 EF54  13                  INC     DE
 1734 EF55  23                  INC     HL
 1735 EF56  C3 EF50             JP      DE2HL1          ;and repeat.
 1736                   ;
 1737                   ;   Select the desired drive.
 1738                   ;
 1739 EF59  3A EF42     SELECT: LD      A,(ACTIVE)      ;get active disk.
 1740 EF5C  4F                  LD      C,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  31
BDOS22  Z80

 1741 EF5D  CD FA1B             CALL    SELDSK          ;select it.
 1742 EF60  7C                  LD      A,H             ;valid drive?
 1743 EF61  B5                  OR      L               ;valid drive?
 1744 EF62  C8                  RET     Z               ;return if not.
 1745                   ;
 1746                   ;   Here, the BIOS returned the address of the parameter block
 1747                   ; in (HL). We will extract the necessary pointers and save them.
 1748                   ;
 1749 EF63  5E                  LD      E,(HL)          ;yes, get address of translation table into (DE).
 1750 EF64  23                  INC     HL
 1751 EF65  56                  LD      D,(HL)
 1752 EF66  23                  INC     HL
 1753 EF67  22 F9B3             LD      (SCRATCH1),HL   ;save pointers to scratch areas.
 1754 EF6A  23                  INC     HL
 1755 EF6B  23                  INC     HL
 1756 EF6C  22 F9B5             LD      (SCRATCH2),HL   ;ditto.
 1757 EF6F  23                  INC     HL
 1758 EF70  23                  INC     HL
 1759 EF71  22 F9B7             LD      (SCRATCH3),HL   ;ditto.
 1760 EF74  23                  INC     HL
 1761 EF75  23                  INC     HL
 1762 EF76  EB                  EX      DE,HL           ;now save the translation table address.
 1763 EF77  22 F9D0             LD      (XLATE),HL
 1764 EF7A  21 F9B9             LD      HL,DIRBUF       ;put the next 8 bytes here.
 1765 EF7D  0E 08               LD      C,8             ;they consist of the directory buffer
 1766 EF7F  CD EF4F             CALL    DE2HL           ;pointer, parameter block pointer,
 1767 EF82  2A F9BB             LD      HL,(DISKPB)     ;check and allocation vectors.
 1768 EF85  EB                  EX      DE,HL
 1769 EF86  21 F9C1             LD      HL,SECTORS      ;move parameter block into our ram.
 1770 EF89  0E 0F               LD      C,15            ;it is 15 bytes long.
 1771 EF8B  CD EF4F             CALL    DE2HL
 1772 EF8E  2A F9C6             LD      HL,(DSKSIZE)    ;check disk size.
 1773 EF91  7C                  LD      A,H             ;more than 256 blocks on this?
 1774 EF92  21 F9DD             LD      HL,BIGDISK
 1775 EF95  36 FF               LD      (HL),0FFH       ;set to samll.
 1776 EF97  B7                  OR      A
 1777 EF98  CA EF9D             JP      Z,SELECT1
 1778 EF9B  36 00               LD      (HL),0          ;wrong, set to large.
 1779 EF9D  3E FF       SELECT1:LD      A,0FFH          ;clear the zero flag.
 1780 EF9F  B7                  OR      A
 1781 EFA0  C9                  RET     
 1782                   ;
 1783                   ;   Routine to home the disk track head and clear pointers.
 1784                   ;
 1785 EFA1  CD FA18     HOMEDRV:CALL    HOME            ;home the head.
 1786 EFA4  AF                  XOR     A
 1787 EFA5  2A F9B5             LD      HL,(SCRATCH2)   ;set our track pointer also.
 1788 EFA8  77                  LD      (HL),A
 1789 EFA9  23                  INC     HL
 1790 EFAA  77                  LD      (HL),A
 1791 EFAB  2A F9B7             LD      HL,(SCRATCH3)   ;and our sector pointer.
 1792 EFAE  77                  LD      (HL),A
 1793 EFAF  23                  INC     HL
 1794 EFB0  77                  LD      (HL),A
 1795 EFB1  C9                  RET     
 1796                   ;
 1797                   ;   Do the actual disk read and check the error return status.
 1798                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  32
BDOS22  Z80

 1799 EFB2  CD FA27     DOREAD: CALL    READ
 1800 EFB5  C3 EFBB             JP      IORET
 1801                   ;
 1802                   ;   Do the actual disk write and handle any bios error.
 1803                   ;
 1804 EFB8  CD FA2A     DOWRITE:CALL    WRITE
 1805 EFBB  B7          IORET:  OR      A
 1806 EFBC  C8                  RET     Z               ;return unless an error occured.
 1807 EFBD  21 EC09             LD      HL,BADSCTR      ;bad read/write on this sector.
 1808 EFC0  C3 EF4A             JP      JUMPHL
 1809                   ;
 1810                   ;   Routine to select the track and sector that the desired
 1811                   ; block number falls in.
 1812                   ;
 1813 EFC3  2A F9EA     TRKSEC: LD      HL,(FILEPOS)    ;get position of last accessed file
 1814 EFC6  0E 02               LD      C,2             ;in directory and compute sector #.
 1815 EFC8  CD F0EA             CALL    SHIFTR          ;sector #=file-position/4.
 1816 EFCB  22 F9E5             LD      (BLKNMBR),HL    ;save this as the block number of interest.
 1817 EFCE  22 F9EC             LD      (CKSUMTBL),HL   ;what's it doing here too?
 1818                   ;
 1819                   ;   if the sector number has already been set (BLKNMBR), enter
 1820                   ; at this point.
 1821                   ;
 1822 EFD1  21 F9E5     TRKSEC1:LD      HL,BLKNMBR
 1823 EFD4  4E                  LD      C,(HL)          ;move sector number into (BC).
 1824 EFD5  23                  INC     HL
 1825 EFD6  46                  LD      B,(HL)
 1826 EFD7  2A F9B7             LD      HL,(SCRATCH3)   ;get current sector number and
 1827 EFDA  5E                  LD      E,(HL)          ;move this into (DE).
 1828 EFDB  23                  INC     HL
 1829 EFDC  56                  LD      D,(HL)
 1830 EFDD  2A F9B5             LD      HL,(SCRATCH2)   ;get current track number.
 1831 EFE0  7E                  LD      A,(HL)          ;and this into (HL).
 1832 EFE1  23                  INC     HL
 1833 EFE2  66                  LD      H,(HL)
 1834 EFE3  6F                  LD      L,A
 1835 EFE4  79          TRKSEC2:LD      A,C             ;is desired sector before current one?
 1836 EFE5  93                  SUB     E
 1837 EFE6  78                  LD      A,B
 1838 EFE7  9A                  SBC     A,D
 1839 EFE8  D2 EFFA             JP      NC,TRKSEC3
 1840 EFEB  E5                  PUSH    HL              ;yes, decrement sectors by one track.
 1841 EFEC  2A F9C1             LD      HL,(SECTORS)    ;get sectors per track.
 1842 EFEF  7B                  LD      A,E
 1843 EFF0  95                  SUB     L
 1844 EFF1  5F                  LD      E,A
 1845 EFF2  7A                  LD      A,D
 1846 EFF3  9C                  SBC     A,H
 1847 EFF4  57                  LD      D,A             ;now we have backed up one full track.
 1848 EFF5  E1                  POP     HL
 1849 EFF6  2B                  DEC     HL              ;adjust track counter.
 1850 EFF7  C3 EFE4             JP      TRKSEC2
 1851 EFFA  E5          TRKSEC3:PUSH    HL              ;desired sector is after current one.
 1852 EFFB  2A F9C1             LD      HL,(SECTORS)    ;get sectors per track.
 1853 EFFE  19                  ADD     HL,DE           ;bump sector pointer to next track.
 1854 EFFF  DA F00F             JP      C,TRKSEC4
 1855 F002  79                  LD      A,C             ;is desired sector now before current one?
 1856 F003  95                  SUB     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  33
BDOS22  Z80

 1857 F004  78                  LD      A,B
 1858 F005  9C                  SBC     A,H
 1859 F006  DA F00F             JP      C,TRKSEC4
 1860 F009  EB                  EX      DE,HL           ;not yes, increment track counter
 1861 F00A  E1                  POP     HL              ;and continue until it is.
 1862 F00B  23                  INC     HL
 1863 F00C  C3 EFFA             JP      TRKSEC3
 1864                   ;
 1865                   ;   here we have determined the track number that contains the
 1866                   ; desired sector.
 1867                   ;
 1868 F00F  E1          TRKSEC4:POP     HL              ;get track number (HL).
 1869 F010  C5                  PUSH    BC
 1870 F011  D5                  PUSH    DE
 1871 F012  E5                  PUSH    HL
 1872 F013  EB                  EX      DE,HL
 1873 F014  2A F9CE             LD      HL,(OFFSET)     ;adjust for first track offset.
 1874 F017  19                  ADD     HL,DE
 1875 F018  44                  LD      B,H
 1876 F019  4D                  LD      C,L
 1877 F01A  CD FA1E             CALL    SETTRK          ;select this track.
 1878 F01D  D1                  POP     DE              ;reset current track pointer.
 1879 F01E  2A F9B5             LD      HL,(SCRATCH2)
 1880 F021  73                  LD      (HL),E
 1881 F022  23                  INC     HL
 1882 F023  72                  LD      (HL),D
 1883 F024  D1                  POP     DE
 1884 F025  2A F9B7             LD      HL,(SCRATCH3)   ;reset the first sector on this track.
 1885 F028  73                  LD      (HL),E
 1886 F029  23                  INC     HL
 1887 F02A  72                  LD      (HL),D
 1888 F02B  C1                  POP     BC
 1889 F02C  79                  LD      A,C             ;now subtract the desired one.
 1890 F02D  93                  SUB     E               ;to make it relative (1-# sectors/track).
 1891 F02E  4F                  LD      C,A
 1892 F02F  78                  LD      A,B
 1893 F030  9A                  SBC     A,D
 1894 F031  47                  LD      B,A
 1895 F032  2A F9D0             LD      HL,(XLATE)      ;translate this sector according to this table.
 1896 F035  EB                  EX      DE,HL
 1897 F036  CD FA30             CALL    SECTRN          ;let the bios translate it.
 1898 F039  4D                  LD      C,L
 1899 F03A  44                  LD      B,H
 1900 F03B  C3 FA21             JP      SETSEC          ;and select it.
 1901                   ;
 1902                   ;   Compute block number from record number (SAVNREC) and
 1903                   ; extent number (SAVEXT).
 1904                   ;
 1905 F03E  21 F9C3     GETBLOCK: LD    HL,BLKSHFT      ;get logical to physical conversion.
 1906 F041  4E                  LD      C,(HL)          ;note that this is base 2 log of ratio.
 1907 F042  3A F9E3             LD      A,(SAVNREC)     ;get record number.
 1908 F045  B7          GETBLK1:OR      A               ;compute (A)=(A)/2^BLKSHFT.
 1909 F046  1F                  RRA     
 1910 F047  0D                  DEC     C
 1911 F048  C2 F045             JP      NZ,GETBLK1
 1912 F04B  47                  LD      B,A             ;save result in (B).
 1913 F04C  3E 08               LD      A,8
 1914 F04E  96                  SUB     (HL)
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  34
BDOS22  Z80

 1915 F04F  4F                  LD      C,A             ;compute (C)=8-BLKSHFT.
 1916 F050  3A F9E2             LD      A,(SAVEXT)
 1917 F053  0D          GETBLK2:DEC     C               ;compute (A)=SAVEXT*2^(8-BLKSHFT).
 1918 F054  CA F05C             JP      Z,GETBLK3
 1919 F057  B7                  OR      A
 1920 F058  17                  RLA     
 1921 F059  C3 F053             JP      GETBLK2
 1922 F05C  80          GETBLK3:ADD     A,B
 1923 F05D  C9                  RET     
 1924                   ;
 1925                   ;   Routine to extract the (BC) block byte from the fcb pointed
 1926                   ; to by (PARAMS). If this is a big-disk, then these are 16 bit
 1927                   ; block numbers, else they are 8 bit numbers.
 1928                   ; Number is returned in (HL).
 1929                   ;
 1930 F05E  2A EF43     EXTBLK: LD      HL,(PARAMS)     ;get fcb address.
 1931 F061  11 0010             LD      DE,16           ;block numbers start 16 bytes into fcb.
 1932 F064  19                  ADD     HL,DE
 1933 F065  09                  ADD     HL,BC
 1934 F066  3A F9DD             LD      A,(BIGDISK)     ;are we using a big-disk?
 1935 F069  B7                  OR      A
 1936 F06A  CA F071             JP      Z,EXTBLK1
 1937 F06D  6E                  LD      L,(HL)          ;no, extract an 8 bit number from the fcb.
 1938 F06E  26 00               LD      H,0
 1939 F070  C9                  RET     
 1940 F071  09          EXTBLK1:ADD     HL,BC           ;yes, extract a 16 bit number.
 1941 F072  5E                  LD      E,(HL)
 1942 F073  23                  INC     HL
 1943 F074  56                  LD      D,(HL)
 1944 F075  EB                  EX      DE,HL           ;return in (HL).
 1945 F076  C9                  RET     
 1946                   ;
 1947                   ;   Compute block number.
 1948                   ;
 1949 F077  CD F03E     COMBLK: CALL    GETBLOCK
 1950 F07A  4F                  LD      C,A
 1951 F07B  06 00               LD      B,0
 1952 F07D  CD F05E             CALL    EXTBLK
 1953 F080  22 F9E5             LD      (BLKNMBR),HL
 1954 F083  C9                  RET     
 1955                   ;
 1956                   ;   Check for a zero block number (unused).
 1957                   ;
 1958 F084  2A F9E5     CHKBLK: LD      HL,(BLKNMBR)
 1959 F087  7D                  LD      A,L             ;is it zero?
 1960 F088  B4                  OR      H
 1961 F089  C9                  RET     
 1962                   ;
 1963                   ;   Adjust physical block (BLKNMBR) and convert to logical
 1964                   ; sector (LOGSECT). This is the starting sector of this block.
 1965                   ; The actual sector of interest is then added to this and the
 1966                   ; resulting sector number is stored back in (BLKNMBR). This
 1967                   ; will still have to be adjusted for the track number.
 1968                   ;
 1969 F08A  3A F9C3     LOGICAL:LD      A,(BLKSHFT)     ;get log2(physical/logical sectors).
 1970 F08D  2A F9E5             LD      HL,(BLKNMBR)    ;get physical sector desired.
 1971 F090  29          LOGICL1:ADD     HL,HL           ;compute logical sector number.
 1972 F091  3D                  DEC     A               ;note logical sectors are 128 bytes long.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  35
BDOS22  Z80

 1973 F092  C2 F090             JP      NZ,LOGICL1
 1974 F095  22 F9E7             LD      (LOGSECT),HL    ;save logical sector.
 1975 F098  3A F9C4             LD      A,(BLKMASK)     ;get block mask.
 1976 F09B  4F                  LD      C,A
 1977 F09C  3A F9E3             LD      A,(SAVNREC)     ;get next sector to access.
 1978 F09F  A1                  AND     C               ;extract the relative position within physical block.
 1979 F0A0  B5                  OR      L               ;and add it too logical sector.
 1980 F0A1  6F                  LD      L,A
 1981 F0A2  22 F9E5             LD      (BLKNMBR),HL    ;and store.
 1982 F0A5  C9                  RET     
 1983                   ;
 1984                   ;   Set (HL) to point to extent byte in fcb.
 1985                   ;
 1986 F0A6  2A EF43     SETEXT: LD      HL,(PARAMS)
 1987 F0A9  11 000C             LD      DE,12           ;it is the twelth byte.
 1988 F0AC  19                  ADD     HL,DE
 1989 F0AD  C9                  RET     
 1990                   ;
 1991                   ;   Set (HL) to point to record count byte in fcb and (DE) to
 1992                   ; next record number byte.
 1993                   ;
 1994 F0AE  2A EF43     SETHLDE:LD      HL,(PARAMS)
 1995 F0B1  11 000F             LD      DE,15           ;record count byte (#15).
 1996 F0B4  19                  ADD     HL,DE
 1997 F0B5  EB                  EX      DE,HL
 1998 F0B6  21 0011             LD      HL,17           ;next record number (#32).
 1999 F0B9  19                  ADD     HL,DE
 2000 F0BA  C9                  RET     
 2001                   ;
 2002                   ;   Save current file data from fcb.
 2003                   ;
 2004 F0BB  CD F0AE     STRDATA:CALL    SETHLDE
 2005 F0BE  7E                  LD      A,(HL)          ;get and store record count byte.
 2006 F0BF  32 F9E3             LD      (SAVNREC),A
 2007 F0C2  EB                  EX      DE,HL
 2008 F0C3  7E                  LD      A,(HL)          ;get and store next record number byte.
 2009 F0C4  32 F9E1             LD      (SAVNXT),A
 2010 F0C7  CD F0A6             CALL    SETEXT          ;point to extent byte.
 2011 F0CA  3A F9C5             LD      A,(EXTMASK)     ;get extent mask.
 2012 F0CD  A6                  AND     (HL)
 2013 F0CE  32 F9E2             LD      (SAVEXT),A      ;and save extent here.
 2014 F0D1  C9                  RET     
 2015                   ;
 2016                   ;   Set the next record to access. If (MODE) is set to 2, then
 2017                   ; the last record byte (SAVNREC) has the correct number to access.
 2018                   ; For sequential access, (MODE) will be equal to 1.
 2019                   ;
 2020 F0D2  CD F0AE     SETNREC:CALL    SETHLDE
 2021 F0D5  3A F9D5             LD      A,(MODE)        ;get sequential flag (=1).
 2022 F0D8  FE 02               CP      2               ;a 2 indicates that no adder is needed.
 2023 F0DA  C2 F0DE             JP      NZ,STNREC1
 2024 F0DD  AF                  XOR     A               ;clear adder (random access?).
 2025 F0DE  4F          STNREC1:LD      C,A
 2026 F0DF  3A F9E3             LD      A,(SAVNREC)     ;get last record number.
 2027 F0E2  81                  ADD     A,C             ;increment record count.
 2028 F0E3  77                  LD      (HL),A          ;and set fcb's next record byte.
 2029 F0E4  EB                  EX      DE,HL
 2030 F0E5  3A F9E1             LD      A,(SAVNXT)      ;get next record byte from storage.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  36
BDOS22  Z80

 2031 F0E8  77                  LD      (HL),A          ;and put this into fcb as number of records used.
 2032 F0E9  C9                  RET     
 2033                   ;
 2034                   ;   Shift (HL) right (C) bits.
 2035                   ;
 2036 F0EA  0C          SHIFTR: INC     C
 2037 F0EB  0D          SHIFTR1:DEC     C
 2038 F0EC  C8                  RET     Z
 2039 F0ED  7C                  LD      A,H
 2040 F0EE  B7                  OR      A
 2041 F0EF  1F                  RRA     
 2042 F0F0  67                  LD      H,A
 2043 F0F1  7D                  LD      A,L
 2044 F0F2  1F                  RRA     
 2045 F0F3  6F                  LD      L,A
 2046 F0F4  C3 F0EB             JP      SHIFTR1
 2047                   ;
 2048                   ;   Compute the check-sum for the directory buffer. Return
 2049                   ; integer sum in (A).
 2050                   ;
 2051 F0F7  0E 80       CHECKSUM: LD    C,128           ;length of buffer.
 2052 F0F9  2A F9B9             LD      HL,(DIRBUF)     ;get its location.
 2053 F0FC  AF                  XOR     A               ;clear summation byte.
 2054 F0FD  86          CHKSUM1:ADD     A,(HL)          ;and compute sum ignoring carries.
 2055 F0FE  23                  INC     HL
 2056 F0FF  0D                  DEC     C
 2057 F100  C2 F0FD             JP      NZ,CHKSUM1
 2058 F103  C9                  RET     
 2059                   ;
 2060                   ;   Shift (HL) left (C) bits.
 2061                   ;
 2062 F104  0C          SHIFTL: INC     C
 2063 F105  0D          SHIFTL1:DEC     C
 2064 F106  C8                  RET     Z
 2065 F107  29                  ADD     HL,HL           ;shift left 1 bit.
 2066 F108  C3 F105             JP      SHIFTL1
 2067                   ;
 2068                   ;   Routine to set a bit in a 16 bit value contained in (BC).
 2069                   ; The bit set depends on the current drive selection.
 2070                   ;
 2071 F10B  C5          SETBIT: PUSH    BC              ;save 16 bit word.
 2072 F10C  3A EF42             LD      A,(ACTIVE)      ;get active drive.
 2073 F10F  4F                  LD      C,A
 2074 F110  21 0001             LD      HL,1
 2075 F113  CD F104             CALL    SHIFTL          ;shift bit 0 into place.
 2076 F116  C1                  POP     BC              ;now 'or' this with the original word.
 2077 F117  79                  LD      A,C
 2078 F118  B5                  OR      L
 2079 F119  6F                  LD      L,A             ;low byte done, do high byte.
 2080 F11A  78                  LD      A,B
 2081 F11B  B4                  OR      H
 2082 F11C  67                  LD      H,A
 2083 F11D  C9                  RET     
 2084                   ;
 2085                   ;   Extract the write protect status bit for the current drive.
 2086                   ; The result is returned in (A), bit 0.
 2087                   ;
 2088 F11E  2A F9AD     GETWPRT:LD      HL,(WRTPRT)     ;get status bytes.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  37
BDOS22  Z80

 2089 F121  3A EF42             LD      A,(ACTIVE)      ;which drive is current?
 2090 F124  4F                  LD      C,A
 2091 F125  CD F0EA             CALL    SHIFTR          ;shift status such that bit 0 is the
 2092 F128  7D                  LD      A,L             ;one of interest for this drive.
 2093 F129  E6 01               AND     01H             ;and isolate it.
 2094 F12B  C9                  RET     
 2095                   ;
 2096                   ;   Function to write protect the current disk.
 2097                   ;
 2098 F12C  21 F9AD     WRTPRTD:LD      HL,WRTPRT       ;point to status word.
 2099 F12F  4E                  LD      C,(HL)          ;set (BC) equal to the status.
 2100 F130  23                  INC     HL
 2101 F131  46                  LD      B,(HL)
 2102 F132  CD F10B             CALL    SETBIT          ;and set this bit according to current drive.
 2103 F135  22 F9AD             LD      (WRTPRT),HL     ;then save.
 2104 F138  2A F9C8             LD      HL,(DIRSIZE)    ;now save directory size limit.
 2105 F13B  23                  INC     HL              ;remember the last one.
 2106 F13C  EB                  EX      DE,HL
 2107 F13D  2A F9B3             LD      HL,(SCRATCH1)   ;and store it here.
 2108 F140  73                  LD      (HL),E          ;put low byte.
 2109 F141  23                  INC     HL
 2110 F142  72                  LD      (HL),D          ;then high byte.
 2111 F143  C9                  RET     
 2112                   ;
 2113                   ;   Check for a read only file.
 2114                   ;
 2115 F144  CD F15E     CHKROFL:CALL    FCB2HL          ;set (HL) to file entry in directory buffer.
 2116 F147  11 0009     CKROF1: LD      DE,9            ;look at bit 7 of the ninth byte.
 2117 F14A  19                  ADD     HL,DE
 2118 F14B  7E                  LD      A,(HL)
 2119 F14C  17                  RLA     
 2120 F14D  D0                  RET     NC              ;return if ok.
 2121 F14E  21 EC0F             LD      HL,ROFILE       ;else, print error message and terminate.
 2122 F151  C3 EF4A             JP      JUMPHL
 2123                   ;
 2124                   ;   Check the write protect status of the active disk.
 2125                   ;
 2126 F154  CD F11E     CHKWPRT:CALL    GETWPRT
 2127 F157  C8                  RET     Z               ;return if ok.
 2128 F158  21 EC0D             LD      HL,RODISK       ;else print message and terminate.
 2129 F15B  C3 EF4A             JP      JUMPHL
 2130                   ;
 2131                   ;   Routine to set (HL) pointing to the proper entry in the
 2132                   ; directory buffer.
 2133                   ;
 2134 F15E  2A F9B9     FCB2HL: LD      HL,(DIRBUF)     ;get address of buffer.
 2135 F161  3A F9E9             LD      A,(FCBPOS)      ;relative position of file.
 2136                   ;
 2137                   ;   Routine to add (A) to (HL).
 2138                   ;
 2139 F164  85          ADDA2HL:ADD     A,L
 2140 F165  6F                  LD      L,A
 2141 F166  D0                  RET     NC
 2142 F167  24                  INC     H               ;take care of any carry.
 2143 F168  C9                  RET     
 2144                   ;
 2145                   ;   Routine to get the 's2' byte from the fcb supplied in
 2146                   ; the initial parameter specification.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  38
BDOS22  Z80

 2147                   ;
 2148 F169  2A EF43     GETS2:  LD      HL,(PARAMS)     ;get address of fcb.
 2149 F16C  11 000E             LD      DE,14           ;relative position of 's2'.
 2150 F16F  19                  ADD     HL,DE
 2151 F170  7E                  LD      A,(HL)          ;extract this byte.
 2152 F171  C9                  RET     
 2153                   ;
 2154                   ;   Clear the 's2' byte in the fcb.
 2155                   ;
 2156 F172  CD F169     CLEARS2:CALL    GETS2           ;this sets (HL) pointing to it.
 2157 F175  36 00               LD      (HL),0          ;now clear it.
 2158 F177  C9                  RET     
 2159                   ;
 2160                   ;   Set bit 7 in the 's2' byte of the fcb.
 2161                   ;
 2162 F178  CD F169     SETS2B7:CALL    GETS2           ;get the byte.
 2163 F17B  F6 80               OR      80H             ;and set bit 7.
 2164 F17D  77                  LD      (HL),A          ;then store.
 2165 F17E  C9                  RET     
 2166                   ;
 2167                   ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
 2168                   ; the difference. This checks to see if there are more file
 2169                   ; names in the directory. We are at (FILEPOS) and there are
 2170                   ; (SCRATCH1) of them to check.
 2171                   ;
 2172 F17F  2A F9EA     MOREFLS:LD      HL,(FILEPOS)    ;we are here.
 2173 F182  EB                  EX      DE,HL
 2174 F183  2A F9B3             LD      HL,(SCRATCH1)   ;and don't go past here.
 2175 F186  7B                  LD      A,E             ;compute difference but don't keep.
 2176 F187  96                  SUB     (HL)
 2177 F188  23                  INC     HL
 2178 F189  7A                  LD      A,D
 2179 F18A  9E                  SBC     A,(HL)          ;set carry if no more names.
 2180 F18B  C9                  RET     
 2181                   ;
 2182                   ;   Call this routine to prevent (SCRATCH1) from being greater
 2183                   ; than (FILEPOS).
 2184                   ;
 2185 F18C  CD F17F     CHKNMBR:CALL    MOREFLS         ;SCRATCH1 too big?
 2186 F18F  D8                  RET     C
 2187 F190  13                  INC     DE              ;yes, reset it to (FILEPOS).
 2188 F191  72                  LD      (HL),D
 2189 F192  2B                  DEC     HL
 2190 F193  73                  LD      (HL),E
 2191 F194  C9                  RET     
 2192                   ;
 2193                   ;   Compute (HL)=(DE)-(HL)
 2194                   ;
 2195 F195  7B          SUBHL:  LD      A,E             ;compute difference.
 2196 F196  95                  SUB     L
 2197 F197  6F                  LD      L,A             ;store low byte.
 2198 F198  7A                  LD      A,D
 2199 F199  9C                  SBC     A,H
 2200 F19A  67                  LD      H,A             ;and then high byte.
 2201 F19B  C9                  RET     
 2202                   ;
 2203                   ;   Set the directory checksum byte.
 2204                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  39
BDOS22  Z80

 2205 F19C  0E FF       SETDIR: LD      C,0FFH
 2206                   ;
 2207                   ;   Routine to set or compare the directory checksum byte. If
 2208                   ; (C)=0ffh, then this will set the checksum byte. Else the byte
 2209                   ; will be checked. If the check fails (the disk has been changed),
 2210                   ; then this disk will be write protected.
 2211                   ;
 2212 F19E  2A F9EC     CHECKDIR: LD    HL,(CKSUMTBL)
 2213 F1A1  EB                  EX      DE,HL
 2214 F1A2  2A F9CC             LD      HL,(ALLOC1)
 2215 F1A5  CD F195             CALL    SUBHL
 2216 F1A8  D0                  RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return.
 2217 F1A9  C5                  PUSH    BC
 2218 F1AA  CD F0F7             CALL    CHECKSUM        ;else compute checksum.
 2219 F1AD  2A F9BD             LD      HL,(CHKVECT)    ;get address of checksum table.
 2220 F1B0  EB                  EX      DE,HL
 2221 F1B1  2A F9EC             LD      HL,(CKSUMTBL)
 2222 F1B4  19                  ADD     HL,DE           ;set (HL) to point to byte for this drive.
 2223 F1B5  C1                  POP     BC
 2224 F1B6  0C                  INC     C               ;set or check ?
 2225 F1B7  CA F1C4             JP      Z,CHKDIR1
 2226 F1BA  BE                  CP      (HL)            ;check them.
 2227 F1BB  C8                  RET     Z               ;return if they are the same.
 2228 F1BC  CD F17F             CALL    MOREFLS         ;not the same, do we care?
 2229 F1BF  D0                  RET     NC
 2230 F1C0  CD F12C             CALL    WRTPRTD         ;yes, mark this as write protected.
 2231 F1C3  C9                  RET     
 2232 F1C4  77          CHKDIR1:LD      (HL),A          ;just set the byte.
 2233 F1C5  C9                  RET     
 2234                   ;
 2235                   ;   Do a write to the directory of the current disk.
 2236                   ;
 2237 F1C6  CD F19C     DIRWRITE: CALL  SETDIR          ;set checksum byte.
 2238 F1C9  CD F1E0             CALL    DIRDMA          ;set directory dma address.
 2239 F1CC  0E 01               LD      C,1             ;tell the bios to actually write.
 2240 F1CE  CD EFB8             CALL    DOWRITE         ;then do the write.
 2241 F1D1  C3 F1DA             JP      DEFDMA
 2242                   ;
 2243                   ;   Read from the directory.
 2244                   ;
 2245 F1D4  CD F1E0     DIRREAD:CALL    DIRDMA          ;set the directory dma address.
 2246 F1D7  CD EFB2             CALL    DOREAD          ;and read it.
 2247                   ;
 2248                   ;   Routine to set the dma address to the users choice.
 2249                   ;
 2250 F1DA  21 F9B1     DEFDMA: LD      HL,USERDMA      ;reset the default dma address and return.
 2251 F1DD  C3 F1E3             JP      DIRDMA1
 2252                   ;
 2253                   ;   Routine to set the dma address for directory work.
 2254                   ;
 2255 F1E0  21 F9B9     DIRDMA: LD      HL,DIRBUF
 2256                   ;
 2257                   ;   Set the dma address. On entry, (HL) points to
 2258                   ; word containing the desired dma address.
 2259                   ;
 2260 F1E3  4E          DIRDMA1:LD      C,(HL)
 2261 F1E4  23                  INC     HL
 2262 F1E5  46                  LD      B,(HL)          ;setup (BC) and go to the bios to set it.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  40
BDOS22  Z80

 2263 F1E6  C3 FA24             JP      SETDMA
 2264                   ;
 2265                   ;   Move the directory buffer into user's dma space.
 2266                   ;
 2267 F1E9  2A F9B9     MOVEDIR:LD      HL,(DIRBUF)     ;buffer is located here, and
 2268 F1EC  EB                  EX      DE,HL
 2269 F1ED  2A F9B1             LD      HL,(USERDMA)    ; put it here.
 2270 F1F0  0E 80               LD      C,128           ;this is its length.
 2271 F1F2  C3 EF4F             JP      DE2HL           ;move it now and return.
 2272                   ;
 2273                   ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
 2274                   ;
 2275 F1F5  21 F9EA     CKFILPOS: LD    HL,FILEPOS
 2276 F1F8  7E                  LD      A,(HL)
 2277 F1F9  23                  INC     HL
 2278 F1FA  BE                  CP      (HL)            ;are both bytes the same?
 2279 F1FB  C0                  RET     NZ
 2280 F1FC  3C                  INC     A               ;yes, but are they each 0ffh?
 2281 F1FD  C9                  RET     
 2282                   ;
 2283                   ;   Set location (FILEPOS) to 0ffffh.
 2284                   ;
 2285 F1FE  21 FFFF     STFILPOS: LD    HL,0FFFFH
 2286 F201  22 F9EA             LD      (FILEPOS),HL
 2287 F204  C9                  RET     
 2288                   ;
 2289                   ;   Move on to the next file position within the current
 2290                   ; directory buffer. If no more exist, set pointer to 0ffffh
 2291                   ; and the calling routine will check for this. Enter with (C)
 2292                   ; equal to 0ffh to cause the checksum byte to be set, else we
 2293                   ; will check this disk and set write protect if checksums are
 2294                   ; not the same (applies only if another directory sector must
 2295                   ; be read).
 2296                   ;
 2297 F205  2A F9C8     NXENTRY:LD      HL,(DIRSIZE)    ;get directory entry size limit.
 2298 F208  EB                  EX      DE,HL
 2299 F209  2A F9EA             LD      HL,(FILEPOS)    ;get current count.
 2300 F20C  23                  INC     HL              ;go on to the next one.
 2301 F20D  22 F9EA             LD      (FILEPOS),HL
 2302 F210  CD F195             CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS)
 2303 F213  D2 F219             JP      NC,NXENT1       ;is there more room left?
 2304 F216  C3 F1FE             JP      STFILPOS        ;no. Set this flag and return.
 2305 F219  3A F9EA     NXENT1: LD      A,(FILEPOS)     ;get file position within directory.
 2306 F21C  E6 03               AND     03H             ;only look within this sector (only 4 entries fit).
 2307 F21E  06 05               LD      B,5             ;convert to relative position (32 bytes each).
 2308 F220  87          NXENT2: ADD     A,A             ;note that this is not efficient code.
 2309 F221  05                  DEC     B               ;5 'ADD A's would be better.
 2310 F222  C2 F220             JP      NZ,NXENT2
 2311 F225  32 F9E9             LD      (FCBPOS),A      ;save it as position of fcb.
 2312 F228  B7                  OR      A
 2313 F229  C0                  RET     NZ              ;return if we are within buffer.
 2314 F22A  C5                  PUSH    BC
 2315 F22B  CD EFC3             CALL    TRKSEC          ;we need the next directory sector.
 2316 F22E  CD F1D4             CALL    DIRREAD
 2317 F231  C1                  POP     BC
 2318 F232  C3 F19E             JP      CHECKDIR
 2319                   ;
 2320                   ;   Routine to to get a bit from the disk space allocation
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  41
BDOS22  Z80

 2321                   ; map. It is returned in (A), bit position 0. On entry to here,
 2322                   ; set (BC) to the block number on the disk to check.
 2323                   ; On return, (D) will contain the original bit position for
 2324                   ; this block number and (HL) will point to the address for it.
 2325                   ;
 2326 F235  79          CKBITMAP: LD    A,C             ;determine bit number of interest.
 2327 F236  E6 07               AND     07H             ;compute (D)=(E)=(C and 7)+1.
 2328 F238  3C                  INC     A
 2329 F239  5F                  LD      E,A             ;save particular bit number.
 2330 F23A  57                  LD      D,A
 2331                   ;
 2332                   ;   compute (BC)=(BC)/8.
 2333                   ;
 2334 F23B  79                  LD      A,C
 2335 F23C  0F                  RRCA                    ;now shift right 3 bits.
 2336 F23D  0F                  RRCA    
 2337 F23E  0F                  RRCA    
 2338 F23F  E6 1F               AND     1FH             ;and clear bits 7,6,5.
 2339 F241  4F                  LD      C,A
 2340 F242  78                  LD      A,B
 2341 F243  87                  ADD     A,A             ;now shift (B) into bits 7,6,5.
 2342 F244  87                  ADD     A,A
 2343 F245  87                  ADD     A,A
 2344 F246  87                  ADD     A,A
 2345 F247  87                  ADD     A,A
 2346 F248  B1                  OR      C               ;and add in (C).
 2347 F249  4F                  LD      C,A             ;ok, (C) ha been completed.
 2348 F24A  78                  LD      A,B             ;is there a better way of doing this?
 2349 F24B  0F                  RRCA    
 2350 F24C  0F                  RRCA    
 2351 F24D  0F                  RRCA    
 2352 F24E  E6 1F               AND     1FH
 2353 F250  47                  LD      B,A             ;and now (B) is completed.
 2354                   ;
 2355                   ;   use this as an offset into the disk space allocation
 2356                   ; table.
 2357                   ;
 2358 F251  2A F9BF             LD      HL,(ALOCVECT)
 2359 F254  09                  ADD     HL,BC
 2360 F255  7E                  LD      A,(HL)          ;now get correct byte.
 2361 F256  07          CKBMAP1:RLCA                    ;get correct bit into position 0.
 2362 F257  1D                  DEC     E
 2363 F258  C2 F256             JP      NZ,CKBMAP1
 2364 F25B  C9                  RET     
 2365                   ;
 2366                   ;   Set or clear the bit map such that block number (BC) will be marked
 2367                   ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
 2368                   ; 1 then it will be set (don't use anyother values).
 2369                   ;
 2370 F25C  D5          STBITMAP: PUSH  DE
 2371 F25D  CD F235             CALL    CKBITMAP        ;get the byte of interest.
 2372 F260  E6 FE               AND     0FEH            ;clear the affected bit.
 2373 F262  C1                  POP     BC
 2374 F263  B1                  OR      C               ;and now set it acording to (C).
 2375                   ;
 2376                   ;  entry to restore the original bit position and then store
 2377                   ; in table. (A) contains the value, (D) contains the bit
 2378                   ; position (1-8), and (HL) points to the address within the
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  42
BDOS22  Z80

 2379                   ; space allocation table for this byte.
 2380                   ;
 2381 F264  0F          STBMAP1:RRCA                    ;restore original bit position.
 2382 F265  15                  DEC     D
 2383 F266  C2 F264             JP      NZ,STBMAP1
 2384 F269  77                  LD      (HL),A          ;and stor byte in table.
 2385 F26A  C9                  RET     
 2386                   ;
 2387                   ;   Set/clear space used bits in allocation map for this file.
 2388                   ; On entry, (C)=1 to set the map and (C)=0 to clear it.
 2389                   ;
 2390 F26B  CD F15E     SETFILE:CALL    FCB2HL          ;get address of fcb
 2391 F26E  11 0010             LD      DE,16
 2392 F271  19                  ADD     HL,DE           ;get to block number bytes.
 2393 F272  C5                  PUSH    BC
 2394 F273  0E 11               LD      C,17            ;check all 17 bytes (max) of table.
 2395 F275  D1          SETFL1: POP     DE
 2396 F276  0D                  DEC     C               ;done all bytes yet?
 2397 F277  C8                  RET     Z
 2398 F278  D5                  PUSH    DE
 2399 F279  3A F9DD             LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers.
 2400 F27C  B7                  OR      A
 2401 F27D  CA F288             JP      Z,SETFL2
 2402 F280  C5                  PUSH    BC              ;only 8 bit numbers. set (BC) to this one.
 2403 F281  E5                  PUSH    HL
 2404 F282  4E                  LD      C,(HL)          ;get low byte from table, always
 2405 F283  06 00               LD      B,0             ;set high byte to zero.
 2406 F285  C3 F28E             JP      SETFL3
 2407 F288  0D          SETFL2: DEC     C               ;for 16 bit block numbers, adjust counter.
 2408 F289  C5                  PUSH    BC
 2409 F28A  4E                  LD      C,(HL)          ;now get both the low and high bytes.
 2410 F28B  23                  INC     HL
 2411 F28C  46                  LD      B,(HL)
 2412 F28D  E5                  PUSH    HL
 2413 F28E  79          SETFL3: LD      A,C             ;block used?
 2414 F28F  B0                  OR      B
 2415 F290  CA F29D             JP      Z,SETFL4
 2416 F293  2A F9C6             LD      HL,(DSKSIZE)    ;is this block number within the
 2417 F296  7D                  LD      A,L             ;space on the disk?
 2418 F297  91                  SUB     C
 2419 F298  7C                  LD      A,H
 2420 F299  98                  SBC     A,B
 2421 F29A  D4 F25C             CALL    NC,STBITMAP     ;yes, set the proper bit.
 2422 F29D  E1          SETFL4: POP     HL              ;point to next block number in fcb.
 2423 F29E  23                  INC     HL
 2424 F29F  C1                  POP     BC
 2425 F2A0  C3 F275             JP      SETFL1
 2426                   ;
 2427                   ;   Construct the space used allocation bit map for the active
 2428                   ; drive. If a file name starts with '$' and it is under the
 2429                   ; current user number, then (STATUS) is set to minus 1. Otherwise
 2430                   ; it is not set at all.
 2431                   ;
 2432 F2A3  2A F9C6     BITMAP: LD      HL,(DSKSIZE)    ;compute size of allocation table.
 2433 F2A6  0E 03               LD      C,3
 2434 F2A8  CD F0EA             CALL    SHIFTR          ;(HL)=(HL)/8.
 2435 F2AB  23                  INC     HL              ;at lease 1 byte.
 2436 F2AC  44                  LD      B,H
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  43
BDOS22  Z80

 2437 F2AD  4D                  LD      C,L             ;set (BC) to the allocation table length.
 2438                   ;
 2439                   ;   Initialize the bitmap for this drive. Right now, the first
 2440                   ; two bytes are specified by the disk parameter block. However
 2441                   ; a patch could be entered here if it were necessary to setup
 2442                   ; this table in a special mannor. For example, the bios could
 2443                   ; determine locations of 'bad blocks' and set them as already
 2444                   ; 'used' in the map.
 2445                   ;
 2446 F2AE  2A F9BF             LD      HL,(ALOCVECT)   ;now zero out the table now.
 2447 F2B1  36 00       BITMAP1:LD      (HL),0
 2448 F2B3  23                  INC     HL
 2449 F2B4  0B                  DEC     BC
 2450 F2B5  78                  LD      A,B
 2451 F2B6  B1                  OR      C
 2452 F2B7  C2 F2B1             JP      NZ,BITMAP1
 2453 F2BA  2A F9CA             LD      HL,(ALLOC0)     ;get initial space used by directory.
 2454 F2BD  EB                  EX      DE,HL
 2455 F2BE  2A F9BF             LD      HL,(ALOCVECT)   ;and put this into map.
 2456 F2C1  73                  LD      (HL),E
 2457 F2C2  23                  INC     HL
 2458 F2C3  72                  LD      (HL),D
 2459                   ;
 2460                   ;   End of initialization portion.
 2461                   ;
 2462 F2C4  CD EFA1             CALL    HOMEDRV         ;now home the drive.
 2463 F2C7  2A F9B3             LD      HL,(SCRATCH1)
 2464 F2CA  36 03               LD      (HL),3          ;force next directory request to read
 2465 F2CC  23                  INC     HL              ;in a sector.
 2466 F2CD  36 00               LD      (HL),0
 2467 F2CF  CD F1FE             CALL    STFILPOS        ;clear initial file position also.
 2468 F2D2  0E FF       BITMAP2:LD      C,0FFH          ;read next file name in directory
 2469 F2D4  CD F205             CALL    NXENTRY         ;and set checksum byte.
 2470 F2D7  CD F1F5             CALL    CKFILPOS        ;is there another file?
 2471 F2DA  C8                  RET     Z
 2472 F2DB  CD F15E             CALL    FCB2HL          ;yes, get its address.
 2473 F2DE  3E E5               LD      A,0E5H
 2474 F2E0  BE                  CP      (HL)            ;empty file entry?
 2475 F2E1  CA F2D2             JP      Z,BITMAP2
 2476 F2E4  3A EF41             LD      A,(USERNO)      ;no, correct user number?
 2477 F2E7  BE                  CP      (HL)
 2478 F2E8  C2 F2F6             JP      NZ,BITMAP3
 2479 F2EB  23                  INC     HL
 2480 F2EC  7E                  LD      A,(HL)          ;yes, does name start with a '$'?
 2481 F2ED  D6 24               SUB     '$'
 2482 F2EF  C2 F2F6             JP      NZ,BITMAP3
 2483 F2F2  3D                  DEC     A               ;yes, set atatus to minus one.
 2484 F2F3  32 EF45             LD      (STATUS),A
 2485 F2F6  0E 01       BITMAP3:LD      C,1             ;now set this file's space as used in bit map.
 2486 F2F8  CD F26B             CALL    SETFILE
 2487 F2FB  CD F18C             CALL    CHKNMBR         ;keep (SCRATCH1) in bounds.
 2488 F2FE  C3 F2D2             JP      BITMAP2
 2489                   ;
 2490                   ;   Set the status (STATUS) and return.
 2491                   ;
 2492 F301  3A F9D4     STSTATUS: LD    A,(FNDSTAT)
 2493 F304  C3 EF01             JP      SETSTAT
 2494                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  44
BDOS22  Z80

 2495                   ;   Check extents in (A) and (C). Set the zero flag if they
 2496                   ; are the same. The number of 16k chunks of disk space that
 2497                   ; the directory extent covers is expressad is (EXTMASK+1).
 2498                   ; No registers are modified.
 2499                   ;
 2500 F307  C5          SAMEXT: PUSH    BC
 2501 F308  F5                  PUSH    AF
 2502 F309  3A F9C5             LD      A,(EXTMASK)     ;get extent mask and use it to
 2503 F30C  2F                  CPL                     ;to compare both extent numbers.
 2504 F30D  47                  LD      B,A             ;save resulting mask here.
 2505 F30E  79                  LD      A,C             ;mask first extent and save in (C).
 2506 F30F  A0                  AND     B
 2507 F310  4F                  LD      C,A
 2508 F311  F1                  POP     AF              ;now mask second extent and compare
 2509 F312  A0                  AND     B               ;with the first one.
 2510 F313  91                  SUB     C
 2511 F314  E6 1F               AND     1FH             ;(* only check buts 0-4 *)
 2512 F316  C1                  POP     BC              ;the zero flag is set if they are the same.
 2513 F317  C9                  RET                     ;restore (BC) and return.
 2514                   ;
 2515                   ;   Search for the first occurence of a file name. On entry,
 2516                   ; register (C) should contain the number of bytes of the fcb
 2517                   ; that must match.
 2518                   ;
 2519 F318  3E FF       FINDFST:LD      A,0FFH
 2520 F31A  32 F9D4             LD      (FNDSTAT),A
 2521 F31D  21 F9D8             LD      HL,COUNTER      ;save character count.
 2522 F320  71                  LD      (HL),C
 2523 F321  2A EF43             LD      HL,(PARAMS)     ;get filename to match.
 2524 F324  22 F9D9             LD      (SAVEFCB),HL    ;and save.
 2525 F327  CD F1FE             CALL    STFILPOS        ;clear initial file position (set to 0ffffh).
 2526 F32A  CD EFA1             CALL    HOMEDRV         ;home the drive.
 2527                   ;
 2528                   ;   Entry to locate the next occurence of a filename within the
 2529                   ; directory. The disk is not expected to have been changed. If
 2530                   ; it was, then it will be write protected.
 2531                   ;
 2532 F32D  0E 00       FINDNXT:LD      C,0             ;write protect the disk if changed.
 2533 F32F  CD F205             CALL    NXENTRY         ;get next filename entry in directory.
 2534 F332  CD F1F5             CALL    CKFILPOS        ;is file position = 0ffffh?
 2535 F335  CA F394             JP      Z,FNDNXT6       ;yes, exit now then.
 2536 F338  2A F9D9             LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match.
 2537 F33B  EB                  EX      DE,HL
 2538 F33C  1A                  LD      A,(DE)
 2539 F33D  FE E5               CP      0E5H            ;empty directory entry?
 2540 F33F  CA F34A             JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *)
 2541 F342  D5                  PUSH    DE
 2542 F343  CD F17F             CALL    MOREFLS         ;more files in directory?
 2543 F346  D1                  POP     DE
 2544 F347  D2 F394             JP      NC,FNDNXT6      ;no more. Exit now.
 2545 F34A  CD F15E     FNDNXT1:CALL    FCB2HL          ;get address of this fcb in directory.
 2546 F34D  3A F9D8             LD      A,(COUNTER)     ;get number of bytes (characters) to check.
 2547 F350  4F                  LD      C,A
 2548 F351  06 00               LD      B,0             ;initialize byte position counter.
 2549 F353  79          FNDNXT2:LD      A,C             ;are we done with the compare?
 2550 F354  B7                  OR      A
 2551 F355  CA F383             JP      Z,FNDNXT5
 2552 F358  1A                  LD      A,(DE)          ;no, check next byte.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  45
BDOS22  Z80

 2553 F359  FE 3F               CP      '?'             ;don't care about this character?
 2554 F35B  CA F37C             JP      Z,FNDNXT4
 2555 F35E  78                  LD      A,B             ;get bytes position in fcb.
 2556 F35F  FE 0D               CP      13              ;don't care about the thirteenth byte either.
 2557 F361  CA F37C             JP      Z,FNDNXT4
 2558 F364  FE 0C               CP      12              ;extent byte?
 2559 F366  1A                  LD      A,(DE)
 2560 F367  CA F373             JP      Z,FNDNXT3
 2561 F36A  96                  SUB     (HL)            ;otherwise compare characters.
 2562 F36B  E6 7F               AND     7FH
 2563 F36D  C2 F32D             JP      NZ,FINDNXT      ;not the same, check next entry.
 2564 F370  C3 F37C             JP      FNDNXT4         ;so far so good, keep checking.
 2565 F373  C5          FNDNXT3:PUSH    BC              ;check the extent byte here.
 2566 F374  4E                  LD      C,(HL)
 2567 F375  CD F307             CALL    SAMEXT
 2568 F378  C1                  POP     BC
 2569 F379  C2 F32D             JP      NZ,FINDNXT      ;not the same, look some more.
 2570                   ;
 2571                   ;   So far the names compare. Bump pointers to the next byte
 2572                   ; and continue until all (C) characters have been checked.
 2573                   ;
 2574 F37C  13          FNDNXT4:INC     DE              ;bump pointers.
 2575 F37D  23                  INC     HL
 2576 F37E  04                  INC     B
 2577 F37F  0D                  DEC     C               ;adjust character counter.
 2578 F380  C3 F353             JP      FNDNXT2
 2579 F383  3A F9EA     FNDNXT5:LD      A,(FILEPOS)     ;return the position of this entry.
 2580 F386  E6 03               AND     03H
 2581 F388  32 EF45             LD      (STATUS),A
 2582 F38B  21 F9D4             LD      HL,FNDSTAT
 2583 F38E  7E                  LD      A,(HL)
 2584 F38F  17                  RLA     
 2585 F390  D0                  RET     NC
 2586 F391  AF                  XOR     A
 2587 F392  77                  LD      (HL),A
 2588 F393  C9                  RET     
 2589                   ;
 2590                   ;   Filename was not found. Set appropriate status.
 2591                   ;
 2592 F394  CD F1FE     FNDNXT6:CALL    STFILPOS        ;set (FILEPOS) to 0ffffh.
 2593 F397  3E FF               LD      A,0FFH          ;say not located.
 2594 F399  C3 EF01             JP      SETSTAT
 2595                   ;
 2596                   ;   Erase files from the directory. Only the first byte of the
 2597                   ; fcb will be affected. It is set to (E5).
 2598                   ;
 2599 F39C  CD F154     ERAFILE:CALL    CHKWPRT         ;is disk write protected?
 2600 F39F  0E 0C               LD      C,12            ;only compare file names.
 2601 F3A1  CD F318             CALL    FINDFST         ;get first file name.
 2602 F3A4  CD F1F5     ERAFIL1:CALL    CKFILPOS        ;any found?
 2603 F3A7  C8                  RET     Z               ;nope, we must be done.
 2604 F3A8  CD F144             CALL    CHKROFL         ;is file read only?
 2605 F3AB  CD F15E             CALL    FCB2HL          ;nope, get address of fcb and
 2606 F3AE  36 E5               LD      (HL),0E5H       ;set first byte to 'empty'.
 2607 F3B0  0E 00               LD      C,0             ;clear the space from the bit map.
 2608 F3B2  CD F26B             CALL    SETFILE
 2609 F3B5  CD F1C6             CALL    DIRWRITE        ;now write the directory sector back out.
 2610 F3B8  CD F32D             CALL    FINDNXT         ;find the next file name.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  46
BDOS22  Z80

 2611 F3BB  C3 F3A4             JP      ERAFIL1         ;and repeat process.
 2612                   ;
 2613                   ;   Look through the space allocation map (bit map) for the
 2614                   ; next available block. Start searching at block number (BC-1).
 2615                   ; The search procedure is to look for an empty block that is
 2616                   ; before the starting block. If not empty, look at a later
 2617                   ; block number. In this way, we return the closest empty block
 2618                   ; on either side of the 'target' block number. This will speed
 2619                   ; access on random devices. For serial devices, this should be
 2620                   ; changed to look in the forward direction first and then start
 2621                   ; at the front and search some more.
 2622                   ;
 2623                   ;   On return, (DE)= block number that is empty and (HL) =0
 2624                   ; if no empry block was found.
 2625                   ;
 2626 F3BE  50          FNDSPACE: LD    D,B             ;set (DE) as the block that is checked.
 2627 F3BF  59                  LD      E,C
 2628                   ;
 2629                   ;   Look before target block. Registers (BC) are used as the lower
 2630                   ; pointer and (DE) as the upper pointer.
 2631                   ;
 2632 F3C0  79          FNDSPA1:LD      A,C             ;is block 0 specified?
 2633 F3C1  B0                  OR      B
 2634 F3C2  CA F3D1             JP      Z,FNDSPA2
 2635 F3C5  0B                  DEC     BC              ;nope, check previous block.
 2636 F3C6  D5                  PUSH    DE
 2637 F3C7  C5                  PUSH    BC
 2638 F3C8  CD F235             CALL    CKBITMAP
 2639 F3CB  1F                  RRA                     ;is this block empty?
 2640 F3CC  D2 F3EC             JP      NC,FNDSPA3      ;yes. use this.
 2641                   ;
 2642                   ;   Note that the above logic gets the first block that it finds
 2643                   ; that is empty. Thus a file could be written 'backward' making
 2644                   ; it very slow to access. This could be changed to look for the
 2645                   ; first empty block and then continue until the start of this
 2646                   ; empty space is located and then used that starting block.
 2647                   ; This should help speed up access to some files especially on
 2648                   ; a well used disk with lots of fairly small 'holes'.
 2649                   ;
 2650 F3CF  C1                  POP     BC              ;nope, check some more.
 2651 F3D0  D1                  POP     DE
 2652                   ;
 2653                   ;   Now look after target block.
 2654                   ;
 2655 F3D1  2A F9C6     FNDSPA2:LD      HL,(DSKSIZE)    ;is block (DE) within disk limits?
 2656 F3D4  7B                  LD      A,E
 2657 F3D5  95                  SUB     L
 2658 F3D6  7A                  LD      A,D
 2659 F3D7  9C                  SBC     A,H
 2660 F3D8  D2 F3F4             JP      NC,FNDSPA4
 2661 F3DB  13                  INC     DE              ;yes, move on to next one.
 2662 F3DC  C5                  PUSH    BC
 2663 F3DD  D5                  PUSH    DE
 2664 F3DE  42                  LD      B,D
 2665 F3DF  4B                  LD      C,E
 2666 F3E0  CD F235             CALL    CKBITMAP        ;check it.
 2667 F3E3  1F                  RRA                     ;empty?
 2668 F3E4  D2 F3EC             JP      NC,FNDSPA3
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  47
BDOS22  Z80

 2669 F3E7  D1                  POP     DE              ;nope, continue searching.
 2670 F3E8  C1                  POP     BC
 2671 F3E9  C3 F3C0             JP      FNDSPA1
 2672                   ;
 2673                   ;   Empty block found. Set it as used and return with (HL)
 2674                   ; pointing to it (true?).
 2675                   ;
 2676 F3EC  17          FNDSPA3:RLA                     ;reset byte.
 2677 F3ED  3C                  INC     A               ;and set bit 0.
 2678 F3EE  CD F264             CALL    STBMAP1         ;update bit map.
 2679 F3F1  E1                  POP     HL              ;set return registers.
 2680 F3F2  D1                  POP     DE
 2681 F3F3  C9                  RET     
 2682                   ;
 2683                   ;   Free block was not found. If (BC) is not zero, then we have
 2684                   ; not checked all of the disk space.
 2685                   ;
 2686 F3F4  79          FNDSPA4:LD      A,C
 2687 F3F5  B0                  OR      B
 2688 F3F6  C2 F3C0             JP      NZ,FNDSPA1
 2689 F3F9  21 0000             LD      HL,0            ;set 'not found' status.
 2690 F3FC  C9                  RET     
 2691                   ;
 2692                   ;   Move a complete fcb entry into the directory and write it.
 2693                   ;
 2694 F3FD  0E 00       FCBSET: LD      C,0
 2695 F3FF  1E 20               LD      E,32            ;length of each entry.
 2696                   ;
 2697                   ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
 2698                   ; fcb in directory starting at relative byte (C). This updated
 2699                   ; directory buffer is then written to the disk.
 2700                   ;
 2701 F401  D5          UPDATE: PUSH    DE
 2702 F402  06 00               LD      B,0             ;set (BC) to relative byte position.
 2703 F404  2A EF43             LD      HL,(PARAMS)     ;get address of fcb.
 2704 F407  09                  ADD     HL,BC           ;compute starting byte.
 2705 F408  EB                  EX      DE,HL
 2706 F409  CD F15E             CALL    FCB2HL          ;get address of fcb to update in directory.
 2707 F40C  C1                  POP     BC              ;set (C) to number of bytes to change.
 2708 F40D  CD EF4F             CALL    DE2HL
 2709 F410  CD EFC3     UPDATE1:CALL    TRKSEC          ;determine the track and sector affected.
 2710 F413  C3 F1C6             JP      DIRWRITE        ;then write this sector out.
 2711                   ;
 2712                   ;   Routine to change the name of all files on the disk with a
 2713                   ; specified name. The fcb contains the current name as the
 2714                   ; first 12 characters and the new name 16 bytes into the fcb.
 2715                   ;
 2716 F416  CD F154     CHGNAMES: CALL  CHKWPRT         ;check for a write protected disk.
 2717 F419  0E 0C               LD      C,12            ;match first 12 bytes of fcb only.
 2718 F41B  CD F318             CALL    FINDFST         ;get first name.
 2719 F41E  2A EF43             LD      HL,(PARAMS)     ;get address of fcb.
 2720 F421  7E                  LD      A,(HL)          ;get user number.
 2721 F422  11 0010             LD      DE,16           ;move over to desired name.
 2722 F425  19                  ADD     HL,DE
 2723 F426  77                  LD      (HL),A          ;keep same user number.
 2724 F427  CD F1F5     CHGNAM1:CALL    CKFILPOS        ;any matching file found?
 2725 F42A  C8                  RET     Z               ;no, we must be done.
 2726 F42B  CD F144             CALL    CHKROFL         ;check for read only file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  48
BDOS22  Z80

 2727 F42E  0E 10               LD      C,16            ;start 16 bytes into fcb.
 2728 F430  1E 0C               LD      E,12            ;and update the first 12 bytes of directory.
 2729 F432  CD F401             CALL    UPDATE
 2730 F435  CD F32D             CALL    FINDNXT         ;get te next file name.
 2731 F438  C3 F427             JP      CHGNAM1         ;and continue.
 2732                   ;
 2733                   ;   Update a files attributes. The procedure is to search for
 2734                   ; every file with the same name as shown in fcb (ignoring bit 7)
 2735                   ; and then to update it (which includes bit 7). No other changes
 2736                   ; are made.
 2737                   ;
 2738 F43B  0E 0C       SAVEATTR: LD    C,12            ;match first 12 bytes.
 2739 F43D  CD F318             CALL    FINDFST         ;look for first filename.
 2740 F440  CD F1F5     SAVATR1:CALL    CKFILPOS        ;was one found?
 2741 F443  C8                  RET     Z               ;nope, we must be done.
 2742 F444  0E 00               LD      C,0             ;yes, update the first 12 bytes now.
 2743 F446  1E 0C               LD      E,12
 2744 F448  CD F401             CALL    UPDATE          ;update filename and write directory.
 2745 F44B  CD F32D             CALL    FINDNXT         ;and get the next file.
 2746 F44E  C3 F440             JP      SAVATR1         ;then continue until done.
 2747                   ;
 2748                   ;  Open a file (name specified in fcb).
 2749                   ;
 2750 F451  0E 0F       OPENIT: LD      C,15            ;compare the first 15 bytes.
 2751 F453  CD F318             CALL    FINDFST         ;get the first one in directory.
 2752 F456  CD F1F5             CALL    CKFILPOS        ;any at all?
 2753 F459  C8                  RET     Z
 2754 F45A  CD F0A6     OPENIT1:CALL    SETEXT          ;point to extent byte within users fcb.
 2755 F45D  7E                  LD      A,(HL)          ;and get it.
 2756 F45E  F5                  PUSH    AF              ;save it and address.
 2757 F45F  E5                  PUSH    HL
 2758 F460  CD F15E             CALL    FCB2HL          ;point to fcb in directory.
 2759 F463  EB                  EX      DE,HL
 2760 F464  2A EF43             LD      HL,(PARAMS)     ;this is the users copy.
 2761 F467  0E 20               LD      C,32            ;move it into users space.
 2762 F469  D5                  PUSH    DE
 2763 F46A  CD EF4F             CALL    DE2HL
 2764 F46D  CD F178             CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified).
 2765 F470  D1                  POP     DE              ;now get the extent byte from this fcb.
 2766 F471  21 000C             LD      HL,12
 2767 F474  19                  ADD     HL,DE
 2768 F475  4E                  LD      C,(HL)          ;into (C).
 2769 F476  21 000F             LD      HL,15           ;now get the record count byte into (B).
 2770 F479  19                  ADD     HL,DE
 2771 F47A  46                  LD      B,(HL)
 2772 F47B  E1                  POP     HL              ;keep the same extent as the user had originally.
 2773 F47C  F1                  POP     AF
 2774 F47D  77                  LD      (HL),A
 2775 F47E  79                  LD      A,C             ;is it the same as in the directory fcb?
 2776 F47F  BE                  CP      (HL)
 2777 F480  78                  LD      A,B             ;if yes, then use the same record count.
 2778 F481  CA F48B             JP      Z,OPENIT2
 2779 F484  3E 00               LD      A,0             ;if the user specified an extent greater than
 2780 F486  DA F48B             JP      C,OPENIT2       ;the one in the directory, then set record count to 0.
 2781 F489  3E 80               LD      A,128           ;otherwise set to maximum.
 2782 F48B  2A EF43     OPENIT2:LD      HL,(PARAMS)     ;set record count in users fcb to (A).
 2783 F48E  11 000F             LD      DE,15
 2784 F491  19                  ADD     HL,DE           ;compute relative position.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  49
BDOS22  Z80

 2785 F492  77                  LD      (HL),A          ;and set the record count.
 2786 F493  C9                  RET     
 2787                   ;
 2788                   ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
 2789                   ; point to a zero value (16 bit).
 2790                   ;   Return with zero flag set it (DE) was moved. Registers (DE)
 2791                   ; and (HL) are not changed. However (A) is.
 2792                   ;
 2793 F494  7E          MOVEWORD: LD    A,(HL)          ;check for a zero word.
 2794 F495  23                  INC     HL
 2795 F496  B6                  OR      (HL)            ;both bytes zero?
 2796 F497  2B                  DEC     HL
 2797 F498  C0                  RET     NZ              ;nope, just return.
 2798 F499  1A                  LD      A,(DE)          ;yes, move two bytes from (DE) into
 2799 F49A  77                  LD      (HL),A          ;this zero space.
 2800 F49B  13                  INC     DE
 2801 F49C  23                  INC     HL
 2802 F49D  1A                  LD      A,(DE)
 2803 F49E  77                  LD      (HL),A
 2804 F49F  1B                  DEC     DE              ;don't disturb these registers.
 2805 F4A0  2B                  DEC     HL
 2806 F4A1  C9                  RET     
 2807                   ;
 2808                   ;   Get here to close a file specified by (fcb).
 2809                   ;
 2810 F4A2  AF          CLOSEIT:XOR     A               ;clear status and file position bytes.
 2811 F4A3  32 EF45             LD      (STATUS),A
 2812 F4A6  32 F9EA             LD      (FILEPOS),A
 2813 F4A9  32 F9EB             LD      (FILEPOS+1),A
 2814 F4AC  CD F11E             CALL    GETWPRT         ;get write protect bit for this drive.
 2815 F4AF  C0                  RET     NZ              ;just return if it is set.
 2816 F4B0  CD F169             CALL    GETS2           ;else get the 's2' byte.
 2817 F4B3  E6 80               AND     80H             ;and look at bit 7 (file unmodified?).
 2818 F4B5  C0                  RET     NZ              ;just return if set.
 2819 F4B6  0E 0F               LD      C,15            ;else look up this file in directory.
 2820 F4B8  CD F318             CALL    FINDFST
 2821 F4BB  CD F1F5             CALL    CKFILPOS        ;was it found?
 2822 F4BE  C8                  RET     Z               ;just return if not.
 2823 F4BF  01 0010             LD      BC,16           ;set (HL) pointing to records used section.
 2824 F4C2  CD F15E             CALL    FCB2HL
 2825 F4C5  09                  ADD     HL,BC
 2826 F4C6  EB                  EX      DE,HL
 2827 F4C7  2A EF43             LD      HL,(PARAMS)     ;do the same for users specified fcb.
 2828 F4CA  09                  ADD     HL,BC
 2829 F4CB  0E 10               LD      C,16            ;this many bytes are present in this extent.
 2830 F4CD  3A F9DD     CLOSEIT1: LD    A,(BIGDISK)     ;8 or 16 bit record numbers?
 2831 F4D0  B7                  OR      A
 2832 F4D1  CA F4E8             JP      Z,CLOSEIT4
 2833 F4D4  7E                  LD      A,(HL)          ;just 8 bit. Get one from users fcb.
 2834 F4D5  B7                  OR      A
 2835 F4D6  1A                  LD      A,(DE)          ;now get one from directory fcb.
 2836 F4D7  C2 F4DB             JP      NZ,CLOSEIT2
 2837 F4DA  77                  LD      (HL),A          ;users byte was zero. Update from directory.
 2838 F4DB  B7          CLOSEIT2: OR    A
 2839 F4DC  C2 F4E1             JP      NZ,CLOSEIT3
 2840 F4DF  7E                  LD      A,(HL)          ;directories byte was zero, update from users fcb.
 2841 F4E0  12                  LD      (DE),A
 2842 F4E1  BE          CLOSEIT3: CP    (HL)            ;if neither one of these bytes were zero,
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  50
BDOS22  Z80

 2843 F4E2  C2 F51F             JP      NZ,CLOSEIT7     ;then close error if they are not the same.
 2844 F4E5  C3 F4FD             JP      CLOSEIT5        ;ok so far, get to next byte in fcbs.
 2845 F4E8  CD F494     CLOSEIT4: CALL  MOVEWORD        ;update users fcb if it is zero.
 2846 F4EB  EB                  EX      DE,HL
 2847 F4EC  CD F494             CALL    MOVEWORD        ;update directories fcb if it is zero.
 2848 F4EF  EB                  EX      DE,HL
 2849 F4F0  1A                  LD      A,(DE)          ;if these two values are no different,
 2850 F4F1  BE                  CP      (HL)            ;then a close error occured.
 2851 F4F2  C2 F51F             JP      NZ,CLOSEIT7
 2852 F4F5  13                  INC     DE              ;check second byte.
 2853 F4F6  23                  INC     HL
 2854 F4F7  1A                  LD      A,(DE)
 2855 F4F8  BE                  CP      (HL)
 2856 F4F9  C2 F51F             JP      NZ,CLOSEIT7
 2857 F4FC  0D                  DEC     C               ;remember 16 bit values.
 2858 F4FD  13          CLOSEIT5: INC   DE              ;bump to next item in table.
 2859 F4FE  23                  INC     HL
 2860 F4FF  0D                  DEC     C               ;there are 16 entries only.
 2861 F500  C2 F4CD             JP      NZ,CLOSEIT1     ;continue if more to do.
 2862 F503  01 FFEC             LD      BC,0FFECH       ;backup 20 places (extent byte).
 2863 F506  09                  ADD     HL,BC
 2864 F507  EB                  EX      DE,HL
 2865 F508  09                  ADD     HL,BC
 2866 F509  1A                  LD      A,(DE)
 2867 F50A  BE                  CP      (HL)            ;directory's extent already greater than the
 2868 F50B  DA F517             JP      C,CLOSEIT6      ;users extent?
 2869 F50E  77                  LD      (HL),A          ;no, update directory extent.
 2870 F50F  01 0003             LD      BC,3            ;and update the record count byte in
 2871 F512  09                  ADD     HL,BC           ;directories fcb.
 2872 F513  EB                  EX      DE,HL
 2873 F514  09                  ADD     HL,BC
 2874 F515  7E                  LD      A,(HL)          ;get from user.
 2875 F516  12                  LD      (DE),A          ;and put in directory.
 2876 F517  3E FF       CLOSEIT6: LD    A,0FFH          ;set 'was open and is now closed' byte.
 2877 F519  32 F9D2             LD      (CLOSEFLG),A
 2878 F51C  C3 F410             JP      UPDATE1         ;update the directory now.
 2879 F51F  21 EF45     CLOSEIT7: LD    HL,STATUS       ;set return status and then return.
 2880 F522  35                  DEC     (HL)
 2881 F523  C9                  RET     
 2882                   ;
 2883                   ;   Routine to get the next empty space in the directory. It
 2884                   ; will then be cleared for use.
 2885                   ;
 2886 F524  CD F154     GETEMPTY: CALL  CHKWPRT         ;make sure disk is not write protected.
 2887 F527  2A EF43             LD      HL,(PARAMS)     ;save current parameters (fcb).
 2888 F52A  E5                  PUSH    HL
 2889 F52B  21 F9AC             LD      HL,EMPTYFCB     ;use special one for empty space.
 2890 F52E  22 EF43             LD      (PARAMS),HL
 2891 F531  0E 01               LD      C,1             ;search for first empty spot in directory.
 2892 F533  CD F318             CALL    FINDFST         ;(* only check first byte *)
 2893 F536  CD F1F5             CALL    CKFILPOS        ;none?
 2894 F539  E1                  POP     HL
 2895 F53A  22 EF43             LD      (PARAMS),HL     ;restore original fcb address.
 2896 F53D  C8                  RET     Z               ;return if no more space.
 2897 F53E  EB                  EX      DE,HL
 2898 F53F  21 000F             LD      HL,15           ;point to number of records for this file.
 2899 F542  19                  ADD     HL,DE
 2900 F543  0E 11               LD      C,17            ;and clear all of this space.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  51
BDOS22  Z80

 2901 F545  AF                  XOR     A
 2902 F546  77          GETMT1: LD      (HL),A
 2903 F547  23                  INC     HL
 2904 F548  0D                  DEC     C
 2905 F549  C2 F546             JP      NZ,GETMT1
 2906 F54C  21 000D             LD      HL,13           ;clear the 's1' byte also.
 2907 F54F  19                  ADD     HL,DE
 2908 F550  77                  LD      (HL),A
 2909 F551  CD F18C             CALL    CHKNMBR         ;keep (SCRATCH1) within bounds.
 2910 F554  CD F3FD             CALL    FCBSET          ;write out this fcb entry to directory.
 2911 F557  C3 F178             JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present).
 2912                   ;
 2913                   ;   Routine to close the current extent and open the next one
 2914                   ; for reading.
 2915                   ;
 2916 F55A  AF          GETNEXT:XOR     A
 2917 F55B  32 F9D2             LD      (CLOSEFLG),A    ;clear close flag.
 2918 F55E  CD F4A2             CALL    CLOSEIT         ;close this extent.
 2919 F561  CD F1F5             CALL    CKFILPOS
 2920 F564  C8                  RET     Z               ;not there???
 2921 F565  2A EF43             LD      HL,(PARAMS)     ;get extent byte.
 2922 F568  01 000C             LD      BC,12
 2923 F56B  09                  ADD     HL,BC
 2924 F56C  7E                  LD      A,(HL)          ;and increment it.
 2925 F56D  3C                  INC     A
 2926 F56E  E6 1F               AND     1FH             ;keep within range 0-31.
 2927 F570  77                  LD      (HL),A
 2928 F571  CA F583             JP      Z,GTNEXT1       ;overflow?
 2929 F574  47                  LD      B,A             ;mask extent byte.
 2930 F575  3A F9C5             LD      A,(EXTMASK)
 2931 F578  A0                  AND     B
 2932 F579  21 F9D2             LD      HL,CLOSEFLG     ;check close flag (0ffh is ok).
 2933 F57C  A6                  AND     (HL)
 2934 F57D  CA F58E             JP      Z,GTNEXT2       ;if zero, we must read in next extent.
 2935 F580  C3 F5AC             JP      GTNEXT3         ;else, it is already in memory.
 2936 F583  01 0002     GTNEXT1:LD      BC,2            ;Point to the 's2' byte.
 2937 F586  09                  ADD     HL,BC
 2938 F587  34                  INC     (HL)            ;and bump it.
 2939 F588  7E                  LD      A,(HL)          ;too many extents?
 2940 F589  E6 0F               AND     0FH
 2941 F58B  CA F5B6             JP      Z,GTNEXT5       ;yes, set error code.
 2942                   ;
 2943                   ;   Get here to open the next extent.
 2944                   ;
 2945 F58E  0E 0F       GTNEXT2:LD      C,15            ;set to check first 15 bytes of fcb.
 2946 F590  CD F318             CALL    FINDFST         ;find the first one.
 2947 F593  CD F1F5             CALL    CKFILPOS        ;none available?
 2948 F596  C2 F5AC             JP      NZ,GTNEXT3
 2949 F599  3A F9D3             LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one?
 2950 F59C  3C                  INC     A               ;0ffh means reading (so not possible).
 2951 F59D  CA F5B6             JP      Z,GTNEXT5       ;or an error.
 2952 F5A0  CD F524             CALL    GETEMPTY        ;we are writing, get an empty entry.
 2953 F5A3  CD F1F5             CALL    CKFILPOS        ;none?
 2954 F5A6  CA F5B6             JP      Z,GTNEXT5       ;error if true.
 2955 F5A9  C3 F5AF             JP      GTNEXT4         ;else we are almost done.
 2956 F5AC  CD F45A     GTNEXT3:CALL    OPENIT1         ;open this extent.
 2957 F5AF  CD F0BB     GTNEXT4:CALL    STRDATA         ;move in updated data (rec #, extent #, etc.)
 2958 F5B2  AF                  XOR     A               ;clear status and return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  52
BDOS22  Z80

 2959 F5B3  C3 EF01             JP      SETSTAT
 2960                   ;
 2961                   ;   Error in extending the file. Too many extents were needed
 2962                   ; or not enough space on the disk.
 2963                   ;
 2964 F5B6  CD EF05     GTNEXT5:CALL    IOERR1          ;set error code, clear bit 7 of 's2'
 2965 F5B9  C3 F178             JP      SETS2B7         ;so this is not written on a close.
 2966                   ;
 2967                   ;   Read a sequential file.
 2968                   ;
 2969 F5BC  3E 01       RDSEQ:  LD      A,1             ;set sequential access mode.
 2970 F5BE  32 F9D5             LD      (MODE),A
 2971 F5C1  3E FF       RDSEQ1: LD      A,0FFH          ;don't allow reading unwritten space.
 2972 F5C3  32 F9D3             LD      (RDWRTFLG),A
 2973 F5C6  CD F0BB             CALL    STRDATA         ;put rec# and ext# into fcb.
 2974 F5C9  3A F9E3             LD      A,(SAVNREC)     ;get next record to read.
 2975 F5CC  21 F9E1             LD      HL,SAVNXT       ;get number of records in extent.
 2976 F5CF  BE                  CP      (HL)            ;within this extent?
 2977 F5D0  DA F5E6             JP      C,RDSEQ2
 2978 F5D3  FE 80               CP      128             ;no. Is this extent fully used?
 2979 F5D5  C2 F5FB             JP      NZ,RDSEQ3       ;no. End-of-file.
 2980 F5D8  CD F55A             CALL    GETNEXT         ;yes, open the next one.
 2981 F5DB  AF                  XOR     A               ;reset next record to read.
 2982 F5DC  32 F9E3             LD      (SAVNREC),A
 2983 F5DF  3A EF45             LD      A,(STATUS)      ;check on open, successful?
 2984 F5E2  B7                  OR      A
 2985 F5E3  C2 F5FB             JP      NZ,RDSEQ3       ;no, error.
 2986 F5E6  CD F077     RDSEQ2: CALL    COMBLK          ;ok. compute block number to read.
 2987 F5E9  CD F084             CALL    CHKBLK          ;check it. Within bounds?
 2988 F5EC  CA F5FB             JP      Z,RDSEQ3        ;no, error.
 2989 F5EF  CD F08A             CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte).
 2990 F5F2  CD EFD1             CALL    TRKSEC1         ;set the track and sector for this block #.
 2991 F5F5  CD EFB2             CALL    DOREAD          ;and read it.
 2992 F5F8  C3 F0D2             JP      SETNREC         ;and set the next record to be accessed.
 2993                   ;
 2994                   ;   Read error occured. Set status and return.
 2995                   ;
 2996 F5FB  C3 EF05     RDSEQ3: JP      IOERR1
 2997                   ;
 2998                   ;   Write the next sequential record.
 2999                   ;
 3000 F5FE  3E 01       WTSEQ:  LD      A,1             ;set sequential access mode.
 3001 F600  32 F9D5             LD      (MODE),A
 3002 F603  3E 00       WTSEQ1: LD      A,0             ;allow an addition empty extent to be opened.
 3003 F605  32 F9D3             LD      (RDWRTFLG),A
 3004 F608  CD F154             CALL    CHKWPRT         ;check write protect status.
 3005 F60B  2A EF43             LD      HL,(PARAMS)
 3006 F60E  CD F147             CALL    CKROF1          ;check for read only file, (HL) already set to fcb.
 3007 F611  CD F0BB             CALL    STRDATA         ;put updated data into fcb.
 3008 F614  3A F9E3             LD      A,(SAVNREC)     ;get record number to write.
 3009 F617  FE 80               CP      128             ;within range?
 3010 F619  D2 EF05             JP      NC,IOERR1       ;no, error(?).
 3011 F61C  CD F077             CALL    COMBLK          ;compute block number.
 3012 F61F  CD F084             CALL    CHKBLK          ;check number.
 3013 F622  0E 00               LD      C,0             ;is there one to write to?
 3014 F624  C2 F66E             JP      NZ,WTSEQ6       ;yes, go do it.
 3015 F627  CD F03E             CALL    GETBLOCK        ;get next block number within fcb to use.
 3016 F62A  32 F9D7             LD      (RELBLOCK),A    ;and save.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  53
BDOS22  Z80

 3017 F62D  01 0000             LD      BC,0            ;start looking for space from the start
 3018 F630  B7                  OR      A               ;if none allocated as yet.
 3019 F631  CA F63B             JP      Z,WTSEQ2
 3020 F634  4F                  LD      C,A             ;extract previous block number from fcb
 3021 F635  0B                  DEC     BC              ;so we can be closest to it.
 3022 F636  CD F05E             CALL    EXTBLK
 3023 F639  44                  LD      B,H
 3024 F63A  4D                  LD      C,L
 3025 F63B  CD F3BE     WTSEQ2: CALL    FNDSPACE        ;find the next empty block nearest number (BC).
 3026 F63E  7D                  LD      A,L             ;check for a zero number.
 3027 F63F  B4                  OR      H
 3028 F640  C2 F648             JP      NZ,WTSEQ3
 3029 F643  3E 02               LD      A,2             ;no more space?
 3030 F645  C3 EF01             JP      SETSTAT
 3031 F648  22 F9E5     WTSEQ3: LD      (BLKNMBR),HL    ;save block number to access.
 3032 F64B  EB                  EX      DE,HL           ;put block number into (DE).
 3033 F64C  2A EF43             LD      HL,(PARAMS)     ;now we must update the fcb for this
 3034 F64F  01 0010             LD      BC,16           ;newly allocated block.
 3035 F652  09                  ADD     HL,BC
 3036 F653  3A F9DD             LD      A,(BIGDISK)     ;8 or 16 bit block numbers?
 3037 F656  B7                  OR      A
 3038 F657  3A F9D7             LD      A,(RELBLOCK)    ;(* update this entry *)
 3039 F65A  CA F664             JP      Z,WTSEQ4        ;zero means 16 bit ones.
 3040 F65D  CD F164             CALL    ADDA2HL         ;(HL)=(HL)+(A)
 3041 F660  73                  LD      (HL),E          ;store new block number.
 3042 F661  C3 F66C             JP      WTSEQ5
 3043 F664  4F          WTSEQ4: LD      C,A             ;compute spot in this 16 bit table.
 3044 F665  06 00               LD      B,0
 3045 F667  09                  ADD     HL,BC
 3046 F668  09                  ADD     HL,BC
 3047 F669  73                  LD      (HL),E          ;stuff block number (DE) there.
 3048 F66A  23                  INC     HL
 3049 F66B  72                  LD      (HL),D
 3050 F66C  0E 02       WTSEQ5: LD      C,2             ;set (C) to indicate writing to un-used disk space.
 3051 F66E  3A EF45     WTSEQ6: LD      A,(STATUS)      ;are we ok so far?
 3052 F671  B7                  OR      A
 3053 F672  C0                  RET     NZ
 3054 F673  C5                  PUSH    BC              ;yes, save write flag for bios (register C).
 3055 F674  CD F08A             CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors.
 3056 F677  3A F9D5             LD      A,(MODE)        ;get access mode flag (1=sequential,
 3057 F67A  3D                  DEC     A               ;0=random, 2=special?).
 3058 F67B  3D                  DEC     A
 3059 F67C  C2 F6BB             JP      NZ,WTSEQ9
 3060                   ;
 3061                   ;   Special random i/o from function #40. Maybe for M/PM, but the
 3062                   ; current block, if it has not been written to, will be zeroed
 3063                   ; out and then written (reason?).
 3064                   ;
 3065 F67F  C1                  POP     BC
 3066 F680  C5                  PUSH    BC
 3067 F681  79                  LD      A,C             ;get write status flag (2=writing unused space).
 3068 F682  3D                  DEC     A
 3069 F683  3D                  DEC     A
 3070 F684  C2 F6BB             JP      NZ,WTSEQ9
 3071 F687  E5                  PUSH    HL
 3072 F688  2A F9B9             LD      HL,(DIRBUF)     ;zero out the directory buffer.
 3073 F68B  57                  LD      D,A             ;note that (A) is zero here.
 3074 F68C  77          WTSEQ7: LD      (HL),A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  54
BDOS22  Z80

 3075 F68D  23                  INC     HL
 3076 F68E  14                  INC     D               ;do 128 bytes.
 3077 F68F  F2 F68C             JP      P,WTSEQ7
 3078 F692  CD F1E0             CALL    DIRDMA          ;tell the bios the dma address for directory access.
 3079 F695  2A F9E7             LD      HL,(LOGSECT)    ;get sector that starts current block.
 3080 F698  0E 02               LD      C,2             ;set 'writing to unused space' flag.
 3081 F69A  22 F9E5     WTSEQ8: LD      (BLKNMBR),HL    ;save sector to write.
 3082 F69D  C5                  PUSH    BC
 3083 F69E  CD EFD1             CALL    TRKSEC1         ;determine its track and sector numbers.
 3084 F6A1  C1                  POP     BC
 3085 F6A2  CD EFB8             CALL    DOWRITE         ;now write out 128 bytes of zeros.
 3086 F6A5  2A F9E5             LD      HL,(BLKNMBR)    ;get sector number.
 3087 F6A8  0E 00               LD      C,0             ;set normal write flag.
 3088 F6AA  3A F9C4             LD      A,(BLKMASK)     ;determine if we have written the entire
 3089 F6AD  47                  LD      B,A             ;physical block.
 3090 F6AE  A5                  AND     L
 3091 F6AF  B8                  CP      B
 3092 F6B0  23                  INC     HL              ;prepare for the next one.
 3093 F6B1  C2 F69A             JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written.
 3094 F6B4  E1                  POP     HL              ;reset next sector number.
 3095 F6B5  22 F9E5             LD      (BLKNMBR),HL
 3096 F6B8  CD F1DA             CALL    DEFDMA          ;and reset dma address.
 3097                   ;
 3098                   ;   Normal disk write. Set the desired track and sector then
 3099                   ; do the actual write.
 3100                   ;
 3101 F6BB  CD EFD1     WTSEQ9: CALL    TRKSEC1         ;determine track and sector for this write.
 3102 F6BE  C1                  POP     BC              ;get write status flag.
 3103 F6BF  C5                  PUSH    BC
 3104 F6C0  CD EFB8             CALL    DOWRITE         ;and write this out.
 3105 F6C3  C1                  POP     BC
 3106 F6C4  3A F9E3             LD      A,(SAVNREC)     ;get number of records in file.
 3107 F6C7  21 F9E1             LD      HL,SAVNXT       ;get last record written.
 3108 F6CA  BE                  CP      (HL)
 3109 F6CB  DA F6D2             JP      C,WTSEQ10
 3110 F6CE  77                  LD      (HL),A          ;we have to update record count.
 3111 F6CF  34                  INC     (HL)
 3112 F6D0  0E 02               LD      C,2
 3113                   ;
 3114                   ;*   This area has been patched to correct disk update problem
 3115                   ;* when using blocking and de-blocking in the BIOS.
 3116                   ;
 3117 F6D2  00          WTSEQ10:NOP                     ;was 'dcr c'
 3118 F6D3  00                  NOP                     ;was 'dcr c'
 3119 F6D4  21 0000             LD      HL,0            ;was 'jnz wtseq99'
 3120                   ;
 3121                   ; *   End of patch.
 3122                   ;
 3123 F6D7  F5                  PUSH    AF
 3124 F6D8  CD F169             CALL    GETS2           ;set 'extent written to' flag.
 3125 F6DB  E6 7F               AND     7FH             ;(* clear bit 7 *)
 3126 F6DD  77                  LD      (HL),A
 3127 F6DE  F1                  POP     AF              ;get record count for this extent.
 3128 F6DF  FE 7F       WTSEQ99:CP      127             ;is it full?
 3129 F6E1  C2 F700             JP      NZ,WTSEQ12
 3130 F6E4  3A F9D5             LD      A,(MODE)        ;yes, are we in sequential mode?
 3131 F6E7  FE 01               CP      1
 3132 F6E9  C2 F700             JP      NZ,WTSEQ12
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  55
BDOS22  Z80

 3133 F6EC  CD F0D2             CALL    SETNREC         ;yes, set next record number.
 3134 F6EF  CD F55A             CALL    GETNEXT         ;and get next empty space in directory.
 3135 F6F2  21 EF45             LD      HL,STATUS       ;ok?
 3136 F6F5  7E                  LD      A,(HL)
 3137 F6F6  B7                  OR      A
 3138 F6F7  C2 F6FE             JP      NZ,WTSEQ11
 3139 F6FA  3D                  DEC     A               ;yes, set record count to -1.
 3140 F6FB  32 F9E3             LD      (SAVNREC),A
 3141 F6FE  36 00       WTSEQ11:LD      (HL),0          ;clear status.
 3142 F700  C3 F0D2     WTSEQ12:JP      SETNREC         ;set next record to access.
 3143                   ;
 3144                   ;   For random i/o, set the fcb for the desired record number
 3145                   ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
 3146                   ; used as follows:
 3147                   ;
 3148                   ;       fcb+35            fcb+34            fcb+33
 3149                   ;  |     'r-2'      |      'r-1'      |      'r-0'     |
 3150                   ;  |7             0 | 7             0 | 7             0|
 3151                   ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
 3152                   ;  |    overflow   | | extra |  extent   |   record #  |
 3153                   ;  | ______________| |_extent|__number___|_____________|
 3154                   ;                     also 's2'
 3155                   ;
 3156                   ;   On entry, register (C) contains 0ffh if this is a read
 3157                   ; and thus we can not access unwritten disk space. Otherwise,
 3158                   ; another extent will be opened (for writing) if required.
 3159                   ;
 3160 F703  AF          POSITION: XOR   A               ;set random i/o flag.
 3161 F704  32 F9D5             LD      (MODE),A
 3162                   ;
 3163                   ;   Special entry (function #40). M/PM ?
 3164                   ;
 3165 F707  C5          POSITN1:PUSH    BC              ;save read/write flag.
 3166 F708  2A EF43             LD      HL,(PARAMS)     ;get address of fcb.
 3167 F70B  EB                  EX      DE,HL
 3168 F70C  21 0021             LD      HL,33           ;now get byte 'r0'.
 3169 F70F  19                  ADD     HL,DE
 3170 F710  7E                  LD      A,(HL)
 3171 F711  E6 7F               AND     7FH             ;keep bits 0-6 for the record number to access.
 3172 F713  F5                  PUSH    AF
 3173 F714  7E                  LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
 3174 F715  17                  RLA     
 3175 F716  23                  INC     HL
 3176 F717  7E                  LD      A,(HL)
 3177 F718  17                  RLA     
 3178 F719  E6 1F               AND     1FH             ;and save this in bits 0-4 of (C).
 3179 F71B  4F                  LD      C,A             ;this is the extent byte.
 3180 F71C  7E                  LD      A,(HL)          ;now get the extra extent byte.
 3181 F71D  1F                  RRA     
 3182 F71E  1F                  RRA     
 3183 F71F  1F                  RRA     
 3184 F720  1F                  RRA     
 3185 F721  E6 0F               AND     0FH
 3186 F723  47                  LD      B,A             ;and save it in (B).
 3187 F724  F1                  POP     AF              ;get record number back to (A).
 3188 F725  23                  INC     HL              ;check overflow byte 'r2'.
 3189 F726  6E                  LD      L,(HL)
 3190 F727  2C                  INC     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  56
BDOS22  Z80

 3191 F728  2D                  DEC     L
 3192 F729  2E 06               LD      L,6             ;prepare for error.
 3193 F72B  C2 F78B             JP      NZ,POSITN5      ;out of disk space error.
 3194 F72E  21 0020             LD      HL,32           ;store record number into fcb.
 3195 F731  19                  ADD     HL,DE
 3196 F732  77                  LD      (HL),A
 3197 F733  21 000C             LD      HL,12           ;and now check the extent byte.
 3198 F736  19                  ADD     HL,DE
 3199 F737  79                  LD      A,C
 3200 F738  96                  SUB     (HL)            ;same extent as before?
 3201 F739  C2 F747             JP      NZ,POSITN2
 3202 F73C  21 000E             LD      HL,14           ;yes, check extra extent byte 's2' also.
 3203 F73F  19                  ADD     HL,DE
 3204 F740  78                  LD      A,B
 3205 F741  96                  SUB     (HL)
 3206 F742  E6 7F               AND     7FH
 3207 F744  CA F77F             JP      Z,POSITN3       ;same, we are almost done then.
 3208                   ;
 3209                   ;  Get here when another extent is required.
 3210                   ;
 3211 F747  C5          POSITN2:PUSH    BC
 3212 F748  D5                  PUSH    DE
 3213 F749  CD F4A2             CALL    CLOSEIT         ;close current extent.
 3214 F74C  D1                  POP     DE
 3215 F74D  C1                  POP     BC
 3216 F74E  2E 03               LD      L,3             ;prepare for error.
 3217 F750  3A EF45             LD      A,(STATUS)
 3218 F753  3C                  INC     A
 3219 F754  CA F784             JP      Z,POSITN4       ;close error.
 3220 F757  21 000C             LD      HL,12           ;put desired extent into fcb now.
 3221 F75A  19                  ADD     HL,DE
 3222 F75B  71                  LD      (HL),C
 3223 F75C  21 000E             LD      HL,14           ;and store extra extent byte 's2'.
 3224 F75F  19                  ADD     HL,DE
 3225 F760  70                  LD      (HL),B
 3226 F761  CD F451             CALL    OPENIT          ;try and get this extent.
 3227 F764  3A EF45             LD      A,(STATUS)      ;was it there?
 3228 F767  3C                  INC     A
 3229 F768  C2 F77F             JP      NZ,POSITN3
 3230 F76B  C1                  POP     BC              ;no. can we create a new one (writing?).
 3231 F76C  C5                  PUSH    BC
 3232 F76D  2E 04               LD      L,4             ;prepare for error.
 3233 F76F  0C                  INC     C
 3234 F770  CA F784             JP      Z,POSITN4       ;nope, reading unwritten space error.
 3235 F773  CD F524             CALL    GETEMPTY        ;yes we can, try to find space.
 3236 F776  2E 05               LD      L,5             ;prepare for error.
 3237 F778  3A EF45             LD      A,(STATUS)
 3238 F77B  3C                  INC     A
 3239 F77C  CA F784             JP      Z,POSITN4       ;out of space?
 3240                   ;
 3241                   ;   Normal return location. Clear error code and return.
 3242                   ;
 3243 F77F  C1          POSITN3:POP     BC              ;restore stack.
 3244 F780  AF                  XOR     A               ;and clear error code byte.
 3245 F781  C3 EF01             JP      SETSTAT
 3246                   ;
 3247                   ;   Error. Set the 's2' byte to indicate this (why?).
 3248                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  57
BDOS22  Z80

 3249 F784  E5          POSITN4:PUSH    HL
 3250 F785  CD F169             CALL    GETS2
 3251 F788  36 C0               LD      (HL),0C0H
 3252 F78A  E1                  POP     HL
 3253                   ;
 3254                   ;   Return with error code (presently in L).
 3255                   ;
 3256 F78B  C1          POSITN5:POP     BC
 3257 F78C  7D                  LD      A,L             ;get error code.
 3258 F78D  32 EF45             LD      (STATUS),A
 3259 F790  C3 F178             JP      SETS2B7
 3260                   ;
 3261                   ;   Read a random record.
 3262                   ;
 3263 F793  0E FF       READRAN:LD      C,0FFH          ;set 'read' status.
 3264 F795  CD F703             CALL    POSITION        ;position the file to proper record.
 3265 F798  CC F5C1             CALL    Z,RDSEQ1        ;and read it as usual (if no errors).
 3266 F79B  C9                  RET     
 3267                   ;
 3268                   ;   Write to a random record.
 3269                   ;
 3270 F79C  0E 00       WRITERAN: LD    C,0             ;set 'writing' flag.
 3271 F79E  CD F703             CALL    POSITION        ;position the file to proper record.
 3272 F7A1  CC F603             CALL    Z,WTSEQ1        ;and write as usual (if no errors).
 3273 F7A4  C9                  RET     
 3274                   ;
 3275                   ;   Compute the random record number. Enter with (HL) pointing
 3276                   ; to a fcb an (DE) contains a relative location of a record
 3277                   ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
 3278                   ; byte, and (A) the 'r2' byte.
 3279                   ;
 3280                   ;   On return, the zero flag is set if the record is within
 3281                   ; bounds. Otherwise, an overflow occured.
 3282                   ;
 3283 F7A5  EB          COMPRAND: EX    DE,HL           ;save fcb pointer in (DE).
 3284 F7A6  19                  ADD     HL,DE           ;compute relative position of record #.
 3285 F7A7  4E                  LD      C,(HL)          ;get record number into (BC).
 3286 F7A8  06 00               LD      B,0
 3287 F7AA  21 000C             LD      HL,12           ;now get extent.
 3288 F7AD  19                  ADD     HL,DE
 3289 F7AE  7E                  LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128.
 3290 F7AF  0F                  RRCA                    ;move lower bit into bit 7.
 3291 F7B0  E6 80               AND     80H             ;and ignore all other bits.
 3292 F7B2  81                  ADD     A,C             ;add to our record number.
 3293 F7B3  4F                  LD      C,A
 3294 F7B4  3E 00               LD      A,0             ;take care of any carry.
 3295 F7B6  88                  ADC     A,B
 3296 F7B7  47                  LD      B,A
 3297 F7B8  7E                  LD      A,(HL)          ;now get the upper bits of extent into
 3298 F7B9  0F                  RRCA                    ;bit positions 0-3.
 3299 F7BA  E6 0F               AND     0FH             ;and ignore all others.
 3300 F7BC  80                  ADD     A,B             ;add this in to 'r1' byte.
 3301 F7BD  47                  LD      B,A
 3302 F7BE  21 000E             LD      HL,14           ;get the 's2' byte (extra extent).
 3303 F7C1  19                  ADD     HL,DE
 3304 F7C2  7E                  LD      A,(HL)
 3305 F7C3  87                  ADD     A,A             ;and shift it left 4 bits (bits 4-7).
 3306 F7C4  87                  ADD     A,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  58
BDOS22  Z80

 3307 F7C5  87                  ADD     A,A
 3308 F7C6  87                  ADD     A,A
 3309 F7C7  F5                  PUSH    AF              ;save carry flag (bit 0 of flag byte).
 3310 F7C8  80                  ADD     A,B             ;now add extra extent into 'r1'.
 3311 F7C9  47                  LD      B,A
 3312 F7CA  F5                  PUSH    AF              ;and save carry (overflow byte 'r2').
 3313 F7CB  E1                  POP     HL              ;bit 0 of (L) is the overflow indicator.
 3314 F7CC  7D                  LD      A,L
 3315 F7CD  E1                  POP     HL              ;and same for first carry flag.
 3316 F7CE  B5                  OR      L               ;either one of these set?
 3317 F7CF  E6 01               AND     01H             ;only check the carry flags.
 3318 F7D1  C9                  RET     
 3319                   ;
 3320                   ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
 3321                   ; reflect the last record used for a random (or other) file.
 3322                   ; This reads the directory and looks at all extents computing
 3323                   ; the largerst record number for each and keeping the maximum
 3324                   ; value only. Then 'r0', 'r1', and 'r2' will reflect this
 3325                   ; maximum record number. This is used to compute the space used
 3326                   ; by a random file.
 3327                   ;
 3328 F7D2  0E 0C       RANSIZE:LD      C,12            ;look thru directory for first entry with
 3329 F7D4  CD F318             CALL    FINDFST         ;this name.
 3330 F7D7  2A EF43             LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes.
 3331 F7DA  11 0021             LD      DE,33
 3332 F7DD  19                  ADD     HL,DE
 3333 F7DE  E5                  PUSH    HL
 3334 F7DF  72                  LD      (HL),D          ;note that (D)=0.
 3335 F7E0  23                  INC     HL
 3336 F7E1  72                  LD      (HL),D
 3337 F7E2  23                  INC     HL
 3338 F7E3  72                  LD      (HL),D
 3339 F7E4  CD F1F5     RANSIZ1:CALL    CKFILPOS        ;is there an extent to process?
 3340 F7E7  CA F80C             JP      Z,RANSIZ3       ;no, we are done.
 3341 F7EA  CD F15E             CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir.
 3342 F7ED  11 000F             LD      DE,15           ;point to last record in extent.
 3343 F7F0  CD F7A5             CALL    COMPRAND        ;and compute random parameters.
 3344 F7F3  E1                  POP     HL
 3345 F7F4  E5                  PUSH    HL              ;now check these values against those
 3346 F7F5  5F                  LD      E,A             ;already in fcb.
 3347 F7F6  79                  LD      A,C             ;the carry flag will be set if those
 3348 F7F7  96                  SUB     (HL)            ;in the fcb represent a larger size than
 3349 F7F8  23                  INC     HL              ;this extent does.
 3350 F7F9  78                  LD      A,B
 3351 F7FA  9E                  SBC     A,(HL)
 3352 F7FB  23                  INC     HL
 3353 F7FC  7B                  LD      A,E
 3354 F7FD  9E                  SBC     A,(HL)
 3355 F7FE  DA F806             JP      C,RANSIZ2
 3356 F801  73                  LD      (HL),E          ;we found a larger (in size) extent.
 3357 F802  2B                  DEC     HL              ;stuff these values into fcb.
 3358 F803  70                  LD      (HL),B
 3359 F804  2B                  DEC     HL
 3360 F805  71                  LD      (HL),C
 3361 F806  CD F32D     RANSIZ2:CALL    FINDNXT         ;now get the next extent.
 3362 F809  C3 F7E4             JP      RANSIZ1         ;continue til all done.
 3363 F80C  E1          RANSIZ3:POP     HL              ;we are done, restore the stack and
 3364 F80D  C9                  RET                     ;return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  59
BDOS22  Z80

 3365                   ;
 3366                   ;   Function to return the random record position of a given
 3367                   ; file which has been read in sequential mode up to now.
 3368                   ;
 3369 F80E  2A EF43     SETRAN: LD      HL,(PARAMS)     ;point to fcb.
 3370 F811  11 0020             LD      DE,32           ;and to last used record.
 3371 F814  CD F7A5             CALL    COMPRAND        ;compute random position.
 3372 F817  21 0021             LD      HL,33           ;now stuff these values into fcb.
 3373 F81A  19                  ADD     HL,DE
 3374 F81B  71                  LD      (HL),C          ;move 'r0'.
 3375 F81C  23                  INC     HL
 3376 F81D  70                  LD      (HL),B          ;and 'r1'.
 3377 F81E  23                  INC     HL
 3378 F81F  77                  LD      (HL),A          ;and lastly 'r2'.
 3379 F820  C9                  RET     
 3380                   ;
 3381                   ;   This routine select the drive specified in (ACTIVE) and
 3382                   ; update the login vector and bitmap table if this drive was
 3383                   ; not already active.
 3384                   ;
 3385 F821  2A F9AF     LOGINDRV: LD    HL,(LOGIN)      ;get the login vector.
 3386 F824  3A EF42             LD      A,(ACTIVE)      ;get the default drive.
 3387 F827  4F                  LD      C,A
 3388 F828  CD F0EA             CALL    SHIFTR          ;position active bit for this drive
 3389 F82B  E5                  PUSH    HL              ;into bit 0.
 3390 F82C  EB                  EX      DE,HL
 3391 F82D  CD EF59             CALL    SELECT          ;select this drive.
 3392 F830  E1                  POP     HL
 3393 F831  CC EF47             CALL    Z,SLCTERR       ;valid drive?
 3394 F834  7D                  LD      A,L             ;is this a newly activated drive?
 3395 F835  1F                  RRA     
 3396 F836  D8                  RET     C
 3397 F837  2A F9AF             LD      HL,(LOGIN)      ;yes, update the login vector.
 3398 F83A  4D                  LD      C,L
 3399 F83B  44                  LD      B,H
 3400 F83C  CD F10B             CALL    SETBIT
 3401 F83F  22 F9AF             LD      (LOGIN),HL      ;and save.
 3402 F842  C3 F2A3             JP      BITMAP          ;now update the bitmap.
 3403                   ;
 3404                   ;   Function to set the active disk number.
 3405                   ;
 3406 F845  3A F9D6     SETDSK: LD      A,(EPARAM)      ;get parameter passed and see if this
 3407 F848  21 EF42             LD      HL,ACTIVE       ;represents a change in drives.
 3408 F84B  BE                  CP      (HL)
 3409 F84C  C8                  RET     Z
 3410 F84D  77                  LD      (HL),A          ;yes it does, log it in.
 3411 F84E  C3 F821             JP      LOGINDRV
 3412                   ;
 3413                   ;   This is the 'auto disk select' routine. The firsst byte
 3414                   ; of the fcb is examined for a drive specification. If non
 3415                   ; zero then the drive will be selected and loged in.
 3416                   ;
 3417 F851  3E FF       AUTOSEL:LD      A,0FFH          ;say 'auto-select activated'.
 3418 F853  32 F9DE             LD      (AUTO),A
 3419 F856  2A EF43             LD      HL,(PARAMS)     ;get drive specified.
 3420 F859  7E                  LD      A,(HL)
 3421 F85A  E6 1F               AND     1FH             ;look at lower 5 bits.
 3422 F85C  3D                  DEC     A               ;adjust for (1=A, 2=B) etc.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  60
BDOS22  Z80

 3423 F85D  32 F9D6             LD      (EPARAM),A      ;and save for the select routine.
 3424 F860  FE 1E               CP      1EH             ;check for 'no change' condition.
 3425 F862  D2 F875             JP      NC,AUTOSL1      ;yes, don't change.
 3426 F865  3A EF42             LD      A,(ACTIVE)      ;we must change, save currently active
 3427 F868  32 F9DF             LD      (OLDDRV),A      ;drive.
 3428 F86B  7E                  LD      A,(HL)          ;and save first byte of fcb also.
 3429 F86C  32 F9E0             LD      (AUTOFLAG),A    ;this must be non-zero.
 3430 F86F  E6 E0               AND     0E0H            ;whats this for (bits 6,7 are used for
 3431 F871  77                  LD      (HL),A          ;something)?
 3432 F872  CD F845             CALL    SETDSK          ;select and log in this drive.
 3433 F875  3A EF41     AUTOSL1:LD      A,(USERNO)      ;move user number into fcb.
 3434 F878  2A EF43             LD      HL,(PARAMS)     ;(* upper half of first byte *)
 3435 F87B  B6                  OR      (HL)
 3436 F87C  77                  LD      (HL),A
 3437 F87D  C9                  RET                     ;and return (all done).
 3438                   ;
 3439                   ;   Function to return the current cp/m version number.
 3440                   ;
 3441 F87E  3E 22       GETVER: LD      A,022H          ;version 2.2
 3442 F880  C3 EF01             JP      SETSTAT
 3443                   ;
 3444                   ;   Function to reset the disk system.
 3445                   ;
 3446 F883  21 0000     RSTDSK: LD      HL,0            ;clear write protect status and log
 3447 F886  22 F9AD             LD      (WRTPRT),HL     ;in vector.
 3448 F889  22 F9AF             LD      (LOGIN),HL
 3449 F88C  AF                  XOR     A               ;select drive 'A'.
 3450 F88D  32 EF42             LD      (ACTIVE),A
 3451 F890  21 0080             LD      HL,TBUFF        ;setup default dma address.
 3452 F893  22 F9B1             LD      (USERDMA),HL
 3453 F896  CD F1DA             CALL    DEFDMA
 3454 F899  C3 F821             JP      LOGINDRV        ;now log in drive 'A'.
 3455                   ;
 3456                   ;   Function to open a specified file.
 3457                   ;
 3458 F89C  CD F172     OPENFIL:CALL    CLEARS2         ;clear 's2' byte.
 3459 F89F  CD F851             CALL    AUTOSEL         ;select proper disk.
 3460 F8A2  C3 F451             JP      OPENIT          ;and open the file.
 3461                   ;
 3462                   ;   Function to close a specified file.
 3463                   ;
 3464 F8A5  CD F851     CLOSEFIL: CALL  AUTOSEL         ;select proper disk.
 3465 F8A8  C3 F4A2             JP      CLOSEIT         ;and close the file.
 3466                   ;
 3467                   ;   Function to return the first occurence of a specified file
 3468                   ; name. If the first byte of the fcb is '?' then the name will
 3469                   ; not be checked (get the first entry no matter what).
 3470                   ;
 3471 F8AB  0E 00       GETFST: LD      C,0             ;prepare for special search.
 3472 F8AD  EB                  EX      DE,HL
 3473 F8AE  7E                  LD      A,(HL)          ;is first byte a '?'?
 3474 F8AF  FE 3F               CP      '?'
 3475 F8B1  CA F8C2             JP      Z,GETFST1       ;yes, just get very first entry (zero length match).
 3476 F8B4  CD F0A6             CALL    SETEXT          ;get the extension byte from fcb.
 3477 F8B7  7E                  LD      A,(HL)          ;is it '?'? if yes, then we want
 3478 F8B8  FE 3F               CP      '?'             ;an entry with a specific 's2' byte.
 3479 F8BA  C4 F172             CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte.
 3480 F8BD  CD F851             CALL    AUTOSEL         ;select proper drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  61
BDOS22  Z80

 3481 F8C0  0E 0F               LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded).
 3482 F8C2  CD F318     GETFST1:CALL    FINDFST         ;find an entry and then move it into
 3483 F8C5  C3 F1E9             JP      MOVEDIR         ;the users dma space.
 3484                   ;
 3485                   ;   Function to return the next occurence of a file name.
 3486                   ;
 3487 F8C8  2A F9D9     GETNXT: LD      HL,(SAVEFCB)    ;restore pointers. note that no
 3488 F8CB  22 EF43             LD      (PARAMS),HL     ;other dbos calls are allowed.
 3489 F8CE  CD F851             CALL    AUTOSEL         ;no error will be returned, but the
 3490 F8D1  CD F32D             CALL    FINDNXT         ;results will be wrong.
 3491 F8D4  C3 F1E9             JP      MOVEDIR
 3492                   ;
 3493                   ;   Function to delete a file by name.
 3494                   ;
 3495 F8D7  CD F851     DELFILE:CALL    AUTOSEL         ;select proper drive.
 3496 F8DA  CD F39C             CALL    ERAFILE         ;erase the file.
 3497 F8DD  C3 F301             JP      STSTATUS        ;set status and return.
 3498                   ;
 3499                   ;   Function to execute a sequential read of the specified
 3500                   ; record number.
 3501                   ;
 3502 F8E0  CD F851     READSEQ:CALL    AUTOSEL         ;select proper drive then read.
 3503 F8E3  C3 F5BC             JP      RDSEQ
 3504                   ;
 3505                   ;   Function to write the net sequential record.
 3506                   ;
 3507 F8E6  CD F851     WRTSEQ: CALL    AUTOSEL         ;select proper drive then write.
 3508 F8E9  C3 F5FE             JP      WTSEQ
 3509                   ;
 3510                   ;   Create a file function.
 3511                   ;
 3512 F8EC  CD F172     FCREATE:CALL    CLEARS2         ;clear the 's2' byte on all creates.
 3513 F8EF  CD F851             CALL    AUTOSEL         ;select proper drive and get the next
 3514 F8F2  C3 F524             JP      GETEMPTY        ;empty directory space.
 3515                   ;
 3516                   ;   Function to rename a file.
 3517                   ;
 3518 F8F5  CD F851     RENFILE:CALL    AUTOSEL         ;select proper drive and then switch
 3519 F8F8  CD F416             CALL    CHGNAMES        ;file names.
 3520 F8FB  C3 F301             JP      STSTATUS
 3521                   ;
 3522                   ;   Function to return the login vector.
 3523                   ;
 3524 F8FE  2A F9AF     GETLOG: LD      HL,(LOGIN)
 3525 F901  C3 F929             JP      GETPRM1
 3526                   ;
 3527                   ;   Function to return the current disk assignment.
 3528                   ;
 3529 F904  3A EF42     GETCRNT:LD      A,(ACTIVE)
 3530 F907  C3 EF01             JP      SETSTAT
 3531                   ;
 3532                   ;   Function to set the dma address.
 3533                   ;
 3534 F90A  EB          PUTDMA: EX      DE,HL
 3535 F90B  22 F9B1             LD      (USERDMA),HL    ;save in our space and then get to
 3536 F90E  C3 F1DA             JP      DEFDMA          ;the bios with this also.
 3537                   ;
 3538                   ;   Function to return the allocation vector.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  62
BDOS22  Z80

 3539                   ;
 3540 F911  2A F9BF     GETALOC:LD      HL,(ALOCVECT)
 3541 F914  C3 F929             JP      GETPRM1
 3542                   ;
 3543                   ;   Function to return the read-only status vector.
 3544                   ;
 3545 F917  2A F9AD     GETROV: LD      HL,(WRTPRT)
 3546 F91A  C3 F929             JP      GETPRM1
 3547                   ;
 3548                   ;   Function to set the file attributes (read-only, system).
 3549                   ;
 3550 F91D  CD F851     SETATTR:CALL    AUTOSEL         ;select proper drive then save attributes.
 3551 F920  CD F43B             CALL    SAVEATTR
 3552 F923  C3 F301             JP      STSTATUS
 3553                   ;
 3554                   ;   Function to return the address of the disk parameter block
 3555                   ; for the current drive.
 3556                   ;
 3557 F926  2A F9BB     GETPARM:LD      HL,(DISKPB)
 3558 F929  22 EF45     GETPRM1:LD      (STATUS),HL
 3559 F92C  C9                  RET     
 3560                   ;
 3561                   ;   Function to get or set the user number. If (E) was (FF)
 3562                   ; then this is a request to return the current user number.
 3563                   ; Else set the user number from (E).
 3564                   ;
 3565 F92D  3A F9D6     GETUSER:LD      A,(EPARAM)      ;get parameter.
 3566 F930  FE FF               CP      0FFH            ;get user number?
 3567 F932  C2 F93B             JP      NZ,SETUSER
 3568 F935  3A EF41             LD      A,(USERNO)      ;yes, just do it.
 3569 F938  C3 EF01             JP      SETSTAT
 3570 F93B  E6 1F       SETUSER:AND     1FH             ;no, we should set it instead. keep low
 3571 F93D  32 EF41             LD      (USERNO),A      ;bits (0-4) only.
 3572 F940  C9                  RET     
 3573                   ;
 3574                   ;   Function to read a random record from a file.
 3575                   ;
 3576 F941  CD F851     RDRANDOM: CALL  AUTOSEL         ;select proper drive and read.
 3577 F944  C3 F793             JP      READRAN
 3578                   ;
 3579                   ;   Function to compute the file size for random files.
 3580                   ;
 3581 F947  CD F851     WTRANDOM: CALL  AUTOSEL         ;select proper drive and write.
 3582 F94A  C3 F79C             JP      WRITERAN
 3583                   ;
 3584                   ;   Function to compute the size of a random file.
 3585                   ;
 3586 F94D  CD F851     FILESIZE: CALL  AUTOSEL         ;select proper drive and check file length
 3587 F950  C3 F7D2             JP      RANSIZE
 3588                   ;
 3589                   ;   Function #37. This allows a program to log off any drives.
 3590                   ; On entry, set (DE) to contain a word with bits set for those
 3591                   ; drives that are to be logged off. The log-in vector and the
 3592                   ; write protect vector will be updated. This must be a M/PM
 3593                   ; special function.
 3594                   ;
 3595 F953  2A EF43     LOGOFF: LD      HL,(PARAMS)     ;get drives to log off.
 3596 F956  7D                  LD      A,L             ;for each bit that is set, we want
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  63
BDOS22  Z80

 3597 F957  2F                  CPL                     ;to clear that bit in (LOGIN)
 3598 F958  5F                  LD      E,A             ;and (WRTPRT).
 3599 F959  7C                  LD      A,H
 3600 F95A  2F                  CPL     
 3601 F95B  2A F9AF             LD      HL,(LOGIN)      ;reset the login vector.
 3602 F95E  A4                  AND     H
 3603 F95F  57                  LD      D,A
 3604 F960  7D                  LD      A,L
 3605 F961  A3                  AND     E
 3606 F962  5F                  LD      E,A
 3607 F963  2A F9AD             LD      HL,(WRTPRT)
 3608 F966  EB                  EX      DE,HL
 3609 F967  22 F9AF             LD      (LOGIN),HL      ;and save.
 3610 F96A  7D                  LD      A,L             ;now do the write protect vector.
 3611 F96B  A3                  AND     E
 3612 F96C  6F                  LD      L,A
 3613 F96D  7C                  LD      A,H
 3614 F96E  A2                  AND     D
 3615 F96F  67                  LD      H,A
 3616 F970  22 F9AD             LD      (WRTPRT),HL     ;and save. all done.
 3617 F973  C9                  RET     
 3618                   ;
 3619                   ;   Get here to return to the user.
 3620                   ;
 3621 F974  3A F9DE     GOBACK: LD      A,(AUTO)        ;was auto select activated?
 3622 F977  B7                  OR      A
 3623 F978  CA F991             JP      Z,GOBACK1
 3624 F97B  2A EF43             LD      HL,(PARAMS)     ;yes, but was a change made?
 3625 F97E  36 00               LD      (HL),0          ;(* reset first byte of fcb *)
 3626 F980  3A F9E0             LD      A,(AUTOFLAG)
 3627 F983  B7                  OR      A
 3628 F984  CA F991             JP      Z,GOBACK1
 3629 F987  77                  LD      (HL),A          ;yes, reset first byte properly.
 3630 F988  3A F9DF             LD      A,(OLDDRV)      ;and get the old drive and select it.
 3631 F98B  32 F9D6             LD      (EPARAM),A
 3632 F98E  CD F845             CALL    SETDSK
 3633 F991  2A EF0F     GOBACK1:LD      HL,(USRSTACK)   ;reset the users stack pointer.
 3634 F994  F9                  LD      SP,HL
 3635 F995  2A EF45             LD      HL,(STATUS)     ;get return status.
 3636 F998  7D                  LD      A,L             ;force version 1.4 compatability.
 3637 F999  44                  LD      B,H
 3638 F99A  C9                  RET                     ;and go back to user.
 3639                   ;
 3640                   ;   Function #40. This is a special entry to do random i/o.
 3641                   ; For the case where we are writing to unused disk space, this
 3642                   ; space will be zeroed out first. This must be a M/PM special
 3643                   ; purpose function, because why would any normal program even
 3644                   ; care about the previous contents of a sector about to be
 3645                   ; written over.
 3646                   ;
 3647 F99B  CD F851     WTSPECL:CALL    AUTOSEL         ;select proper drive.
 3648 F99E  3E 02               LD      A,2             ;use special write mode.
 3649 F9A0  32 F9D5             LD      (MODE),A
 3650 F9A3  0E 00               LD      C,0             ;set write indicator.
 3651 F9A5  CD F707             CALL    POSITN1         ;position the file.
 3652 F9A8  CC F603             CALL    Z,WTSEQ1        ;and write (if no errors).
 3653 F9AB  C9                  RET     
 3654                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  64
BDOS22  Z80

 3655                   ;**************************************************************
 3656                   ;*
 3657                   ;*     BDOS data storage pool.
 3658                   ;*
 3659                   ;**************************************************************
 3660                   ;
 3661 F9AC  E5          EMPTYFCB:  DB   0E5H            ;empty directory segment indicator.
 3662 F9AD  0000        WRTPRT:  DW     0               ;write protect status for all 16 drives.
 3663 F9AF  0000        LOGIN:   DW     0               ;drive active word (1 bit per drive).
 3664 F9B1  0080        USERDMA: DW     080H            ;user's dma address (defaults to 80h).
 3665                   ;
 3666                   ;   Scratch areas from parameter block.
 3667                   ;
 3668 F9B3  0000        SCRATCH1:  DW   0               ;relative position within dir segment for file (0-3).
 3669 F9B5  0000        SCRATCH2:  DW   0               ;last selected track number.
 3670 F9B7  0000        SCRATCH3:  DW   0               ;last selected sector number.
 3671                   ;
 3672                   ;   Disk storage areas from parameter block.
 3673                   ;
 3674 F9B9  0000        DIRBUF:  DW     0               ;address of directory buffer to use.
 3675 F9BB  0000        DISKPB:  DW     0               ;contains address of disk parameter block.
 3676 F9BD  0000        CHKVECT: DW     0               ;address of check vector.
 3677 F9BF  0000        ALOCVECT:  DW   0               ;address of allocation vector (bit map).
 3678                   ;
 3679                   ;   Parameter block returned from the bios.
 3680                   ;
 3681 F9C1  0000        SECTORS: DW     0               ;sectors per track from bios.
 3682 F9C3  00          BLKSHFT: DB     0               ;block shift.
 3683 F9C4  00          BLKMASK: DB     0               ;block mask.
 3684 F9C5  00          EXTMASK: DB     0               ;extent mask.
 3685 F9C6  0000        DSKSIZE: DW     0               ;disk size from bios (number of blocks-1).
 3686 F9C8  0000        DIRSIZE: DW     0               ;directory size.
 3687 F9CA  0000        ALLOC0:  DW     0               ;storage for first bytes of bit map (dir space used).
 3688 F9CC  0000        ALLOC1:  DW     0
 3689 F9CE  0000        OFFSET:  DW     0               ;first usable track number.
 3690 F9D0  0000        XLATE:   DW     0               ;sector translation table address.
 3691                   ;
 3692                   ;
 3693 F9D2  00          CLOSEFLG:  DB   0               ;close flag (=0ffh is extent written ok).
 3694 F9D3  00          RDWRTFLG:  DB   0               ;read/write flag (0ffh=read, 0=write).
 3695 F9D4  00          FNDSTAT: DB     0               ;filename found status (0=found first entry).
 3696 F9D5  00          MODE:    DB     0               ;I/o mode select (0=random, 1=sequential, 2=special random).
 3697 F9D6  00          EPARAM:  DB     0               ;storage for register (E) on entry to bdos.
 3698 F9D7  00          RELBLOCK:  DB   0               ;relative position within fcb of block number written.
 3699 F9D8  00          COUNTER: DB     0               ;byte counter for directory name searches.
 3700 F9D9  0000  0000  SAVEFCB: DW     0,0             ;save space for address of fcb (for directory searches).
 3701 F9DD  00          BIGDISK: DB     0               ;if =0 then disk is > 256 blocks long.
 3702 F9DE  00          AUTO:    DB     0               ;if non-zero, then auto select activated.
 3703 F9DF  00          OLDDRV:  DB     0               ;on auto select, storage for previous drive.
 3704 F9E0  00          AUTOFLAG:  DB   0               ;if non-zero, then auto select changed drives.
 3705 F9E1  00          SAVNXT:  DB     0               ;storage for next record number to access.
 3706 F9E2  00          SAVEXT:  DB     0               ;storage for extent number of file.
 3707 F9E3  0000        SAVNREC: DW     0               ;storage for number of records in file.
 3708 F9E5  0000        BLKNMBR: DW     0               ;block number (physical sector) used within a file or logical sect
 3709 F9E7  0000        LOGSECT: DW     0               ;starting logical (128 byte) sector of block (physical sector).
 3710 F9E9  00          FCBPOS:  DB     0               ;relative position within buffer for fcb of file of interest.
 3711 F9EA  0000        FILEPOS: DW     0               ;files position within directory (0 to max entries -1).
 3712                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  65
BDOS22  Z80

 3713                   ;   Disk directory buffer checksum bytes. One for each of the
 3714                   ; 16 possible drives.
 3715                   ;
 3716 F9EC  00 00 00 00 CKSUMTBL:  DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 3717                   ;
 3718                   ;   Extra space ?
 3719                   ;
 3720 F9FC  00 00 00 00          DB     0,0,0,0
 3721                   ;
 3722                   ;**************************************************************
 3723                   ;*
 3724                   ;*        B I O S   J U M P   T A B L E
 3725                   ;*
 3726                   ;**************************************************************
 3727                   ;
 3728         FA00      BOOT:    EQU $+0
 3729         FA03      WBOOT:   EQU $+3
 3730         FA06      CONST:   EQU $+6
 3731         FA09      CONIN:   EQU $+9
 3732         FA0C      CONOUT:  EQU $+12
 3733         FA0F      LIST:    EQU $+15
 3734         FA12      PUNCH:   EQU $+18
 3735         FA15      READER:  EQU $+21
 3736         FA18      HOME:    EQU $+24
 3737         FA1B      SELDSK:  EQU $+27
 3738         FA1E      SETTRK:  EQU $+30
 3739         FA21      SETSEC:  EQU $+33
 3740         FA24      SETDMA:  EQU $+36
 3741         FA27      READ:    EQU $+39
 3742         FA2A      WRITE:   EQU $+42
 3743         FA2D      PRSTAT:  EQU $+45
 3744         FA30      SECTRN:  EQU $+48
 3745                   ;
 3746                   ;*
 3747                   ;******************   E N D   O F   C P / M   *****************
 3748                   ;*
 3749                            END
 0 Error(s) Detected.
 5632 Absolute Bytes. 499 Symbols Detected.
